<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ STL入门</title>
    <url>/2024/06/06/stl/</url>
    <content><![CDATA[<h1 id="C-STL入门"><a href="#C-STL入门" class="headerlink" title="C++ STL入门"></a>C++ STL入门</h1><h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><blockquote>
<p>STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”与“算法”的集合，所谓的这些“容器”无非就是已经实现好了数据结构，能够让程序设计者更为方便的进行调用，“算法”则顾名思义就是已预先实现好了的算法集合。</p>
</blockquote>
<pre><code>&gt; STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。STL的版本很多，有很多公司或者工作室自定义STL形成各种各样的自定义标准。
</code></pre>
<h2 id="在C-STL中最基本的15个头文件"><a href="#在C-STL中最基本的15个头文件" class="headerlink" title="在C++ STL中最基本的15个头文件"></a>在C++ STL中最基本的15个头文件</h2><p><algorithm> 	<deque> 	<functional> 	<iterator> 	<vector><br><list> 	<map> 	<memory> 	<numeric> 	<queue><br><set> 	<stack> 	<string> 	<array> 	<utility></p>
<h2 id="STL中包含的六大内容"><a href="#STL中包含的六大内容" class="headerlink" title="STL中包含的六大内容"></a>STL中包含的六大内容</h2><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><pre><code>是一种数据结构，也是本章节提的重点，如list(链表)，vector(向量数组)，stack(栈)，队列(queue) ，以模板类的方法提供，为了访问容器中的数据，可以使用由容器类输出的迭代器。
</code></pre>
<h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><pre><code>是一种特殊的指针，它提供了访问容器中对象的方法，在程序设计中，它扮演了容器和算法之间的胶合剂，利用迭代器可以快速而安全的对容器内容进行操作，或是进行算法模板的使用。
</code></pre>
<h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><pre><code>（部分书籍称为泛型算法，generic algorithms），是一类常用的算法模板，既可以对容器进行操作，同时其开放性也让算法类本身可以针对数组或者是自定义结构体等结构进行直接的操作。
</code></pre>
<h3 id="仿函数（Function-object）（又称为函数对象，function-object）"><a href="#仿函数（Function-object）（又称为函数对象，function-object）" class="headerlink" title="仿函数（Function object）（又称为函数对象，function object）"></a>仿函数（Function object）（又称为函数对象，function object）</h3><pre><code>是一种行为类似函数，这样讲可能有些抽象，我们可以理解为一种高级的，重载了()操作符的结构体与类。
迭代适配器（Iterator Adaptor）
是一种用来修饰容器或者仿函数的接口，它使得得带适配器使算法能够以逆向模式，安插模式进行工作，甚至还可以与流配合，它对容器起到非常大的辅助作用，同时他还将迭代器进行了更高级别的抽象。
</code></pre>
<h3 id="空间配制器（allocator）"><a href="#空间配制器（allocator）" class="headerlink" title="空间配制器（allocator）"></a>空间配制器（allocator）</h3><pre><code>是负责空间的配置与管理，重点就是对容器的空间申请和空间释放进行管理，你可以理解为C的malloc和free函数，C++的new和delete关键字。
</code></pre>
<p><strong>我们主要研究前三项</strong></p>
<p><strong>容器篇</strong><br><a href="">Vector容器</a><br>持续更新中,敬请期待…</p>
<p><strong>算法篇</strong><br>持续更新中,敬请期待…</p>
<p><strong>迭代器篇</strong><br>持续更新中,敬请期待…</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector容器</title>
    <url>/2024/06/06/vector/</url>
    <content><![CDATA[<h1 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Vector可以翻译为向量，或向量数组，至于为什么以向量命名，可以理解为一维空间也是存在向量的。<br>Vector是最简单的序列是容器，就像数组一样，向量使用连续的存储位置作为元素，这意味着它们的元素也可以使用常量指向其元素的偏移来访问，与数组一样有效。但与数组不同，它们的大小可以动态变化，其存储由容器自动处理。<br>总结一下Vector就是一个动态创建空间，且预先加载了常用的数组操作的数组</p>
</blockquote>
<h2 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vector<T> v1;</td>
<td align="right">v1 是一个元素类型为 T 的空 vector</td>
</tr>
<tr>
<td align="left">vector<T> v2(v1);</td>
<td align="right">使用 v2 中所有元素初始化 v1</td>
</tr>
<tr>
<td align="left">vector<T> v2 &#x3D; v1;</td>
<td align="right">同上</td>
</tr>
<tr>
<td align="left">vector<T> v3(n, val);</td>
<td align="right">v3 中包含了 n 个值为 val 的元素</td>
</tr>
<tr>
<td align="left">vector<T> v4(n);</td>
<td align="right">v3 中包含了 n 个默认值初始化的元素</td>
</tr>
<tr>
<td align="left">vector<T> v5{a, b, c…};</td>
<td align="right">使用 a, b, c… 初始化 v5</td>
</tr>
<tr>
<td align="left">vector<T> v1;</td>
<td align="right">同上</td>
</tr>
<tr>
<td align="left">vector&lt;vector<int>&gt; matrix(M,vector<int>(N));</td>
<td align="right">二维数组初始化</td>
</tr>
</tbody></table>
<h2 id="vector-常用基础操作"><a href="#vector-常用基础操作" class="headerlink" title="vector 常用基础操作"></a>vector 常用基础操作</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v.empty();</td>
<td align="right">如果 v 为空则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">v.size();</td>
<td align="right">返回 v 中元素的个数</td>
</tr>
<tr>
<td align="left">v.push_back(val);</td>
<td align="right">向 vector 的尾端添加值为 val 的元素。</td>
</tr>
<tr>
<td align="left">v.pop_back(val);</td>
<td align="right">删除尾元素，返回void。vector同样 不支持 pop_front 操作。</td>
</tr>
<tr>
<td align="left">v[n];</td>
<td align="right">返回 v 中第 n 个位置上元素的引用，不能用下标操作添加元素</td>
</tr>
<tr>
<td align="left">v.back();</td>
<td align="right">返回 v 中最后一个元素的引用</td>
</tr>
<tr>
<td align="left">v.front();</td>
<td align="right">返回 v 中第一个元素的引用</td>
</tr>
<tr>
<td align="left">v1 &#x3D; v2;</td>
<td align="right">用 v2 中的元素替换 v1 中的元素</td>
</tr>
<tr>
<td align="left">v1 &#x3D; {a, b, c…};</td>
<td align="right">用元素 {a, b, c…} 替换 v1 中的元素</td>
</tr>
<tr>
<td align="left">v1 &#x3D;&#x3D; v2;</td>
<td align="right">当且仅当拥有相同数量且相同位置上值相同的元素时，v1 与 v2 相等</td>
</tr>
<tr>
<td align="left">v1 !&#x3D; v2;</td>
<td align="right">自行体会</td>
</tr>
<tr>
<td align="left">&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</td>
<td align="right">以字典序进行比较</td>
</tr>
</tbody></table>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p><strong>插入</strong></p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void push_back(const T&amp; x);</td>
<td align="right">向量尾部增加一个元素X</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,const T&amp; x);</td>
<td align="right">向量中迭代器指向元素前增加一个元素x</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,int n,const T&amp; x);</td>
<td align="right">向量中迭代器指向元素前增加n个相同的元素x</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,const_iterator first,const_iterator last);</td>
<td align="right">向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</td>
</tr>
</tbody></table>
<p><strong>删除</strong></p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iterator erase(iterator it);</td>
<td align="right">删除向量中迭代器指向元素</td>
</tr>
<tr>
<td align="left">iterator erase(iterator first,iterator last);</td>
<td align="right">删除向量中[first,last)中元素</td>
</tr>
<tr>
<td align="left">void pop_back();</td>
<td align="right">删除向量中最后一个元素</td>
</tr>
<tr>
<td align="left">void clear();</td>
<td align="right">清空向量中所有元素</td>
</tr>
</tbody></table>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reference at(int pos);</td>
<td align="right">返回pos位置元素的引用</td>
</tr>
<tr>
<td align="left">reference front();</td>
<td align="right">返回首元素的引用</td>
</tr>
<tr>
<td align="left">reference back();</td>
<td align="right">返回尾元素的引用</td>
</tr>
<tr>
<td align="left">iterator begin();</td>
<td align="right">返回向量头指针，指向第一个元素</td>
</tr>
<tr>
<td align="left">iterator end();</td>
<td align="right">返回向量尾指针，指向向量最后一个元素的下一个位置</td>
</tr>
<tr>
<td align="left">reverse_iterator rbegin();</td>
<td align="right">反向迭代器，指向最后一个元素</td>
</tr>
<tr>
<td align="left">reverse_iterator rend();</td>
<td align="right">反向迭代器，指向第一个元素之前的位置</td>
</tr>
</tbody></table>
<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int size() const;</td>
<td align="right">返回向量中元素的个数</td>
</tr>
<tr>
<td align="left">int capacity() const;</td>
<td align="right">返回当前向量所能容纳的最大元素值</td>
</tr>
<tr>
<td align="left">int max_size() const;</td>
<td align="right">返回最大可允许的vector元素数量值</td>
</tr>
</tbody></table>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool empty() const;</td>
<td align="right">判断向量是否为空，若为空，则向量中无元素</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void swap(vector&amp;);</td>
<td align="right">交换两个同类型向量的数据</td>
</tr>
<tr>
<td align="left">void assign(int n,const T&amp; x);</td>
<td align="right">设置向量中前n个元素的值为x</td>
</tr>
<tr>
<td align="left">void assign(const_iterator first,const_iterator last);</td>
<td align="right">向量中[first,last)中元素设置成当前向量元素</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>STL</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2024/06/06/backtracking/</url>
    <content><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。<br>例题</p>
</blockquote>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>   给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>s<br>  <strong>输入</strong>:<br><code>n = 4, k = 2</code><br><strong>输出</strong>:<br><code>    [        [2,4],        [3,4],        [2,3],        [1,2],        [1,3],        [1,4],     ]</code></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> temp_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp_size + (n - cur + <span class="number">1</span>) &lt; k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp_size == k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            cout &lt;&lt; temp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[temp_size++] = cur;</span><br><span class="line">    <span class="built_in">combination</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp_size--;</span><br><span class="line">    <span class="built_in">combination</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="type">int</span>[k];</span><br><span class="line">    <span class="built_in">combination</span>(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵找字符串"><a href="#矩阵找字符串" class="headerlink" title="矩阵找字符串"></a>矩阵找字符串</h2><blockquote>
<p> <strong>题目描述</strong><br>   在字符矩阵中查找给定字符串的所有匹配项<br>   给定一个M×N字符矩阵，以及一个字符串S，找到在矩阵中所有可能的连续字符组成的S的次数。所谓的连续字符，是指一个字符可以和位于其上下左右，左上左下，右上右下8个方向的字符组成字符串。用回溯法求解。<br>  <strong>输入描述</strong><br>    输入整数M,N，表示矩阵的行数和列数。<br>    接下来输入M行，每行输入N列个字符<br>    第M+1行输入一个需要在矩阵中查找的字符串S<br>    <strong>输出描述</strong><br>    共一行，表示测试用例中矩阵中字符串出现的次数<br><strong>样例输入</strong><br><code>5 5 D E M X B A O E P E D D C O D E B E D S C P Y E N CODE</code><br><strong>样例输出</strong><br><code>8      </code></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_path</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; martix, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos, <span class="type">int</span> cur_len, string tar)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (martix[pos.first][pos.second] != tar[cur_len])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cur_len++;</span><br><span class="line">        <span class="keyword">if</span> (tar.<span class="built_in">length</span>() == cur_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= pos.first + i &amp;&amp; pos.first + i &lt; martix.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= pos.second + j &amp;&amp; pos.second + j &lt; martix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                count += <span class="built_in">count_path</span>(martix, <span class="built_in">make_pair</span>(pos.first + i, pos.second + j), cur_len, tar);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">martix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; martix[i][j];</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            count += <span class="built_in">count_path</span>(martix, <span class="built_in">make_pair</span>(i, j), <span class="number">0</span>, s);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>BackTracking</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法</title>
    <url>/2024/06/06/graph/</url>
    <content><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h2><p><strong>图的概念</strong></p>
<blockquote>
<p> 一个图，由顶点(vertex)集和边(edge)集E组成。每一条边，连接了两个顶点，也就是一个点对。</p>
</blockquote>
<p><strong>有向图 无向图</strong></p>
<pre><code>如果点对之后是分次序的（比如仅限于从A点到B点），那么这这个图就是有向图(digraph)。此时我们可以把边叫做弧(arc)。

如果没有次序的差别，那么就是无向图。
</code></pre>
<p><img src="/2024/06/06/graph/1.jpg" alt="图-无向图和有向图"></p>
<p><strong>连通 强连通 弱连通</strong></p>
<pre><code>在上图的无向图中，由B到A，可以走B→A，也可以走B→C→A，还可以走B→C→D→A。

在上图的有向图中，由B到A，因为受到次序的限制，只能走B→A，B→C→A。

对于这样的线路，除了出发的顶点和结束的顶点之外，要求经过的顶点都不相同。这样这样的一组顶点序列就叫做一条路径。

对于无向图，如果任意两个顶点都能找到一条路径，这个无向图就是连通的。

对于有向图，在弧方向的限制下，如果任意两个顶点都能找到一条路径，这个有向图就是强连通的。如果去掉弧的指向才能满足条件，那么就是弱连通的。
</code></pre>
<p><strong>完全图</strong></p>
<pre><code>当一个图中，每一个点和任意另一个点之间都是点对（都由边连接），这个图就是完全图。
</code></pre>
<p><img src="/2024/06/06/graph/2.jpg" alt="图-完全图"></p>
<p><strong>网</strong></p>
<pre><code>网：图的边具有一定的意义，每条边都对应着一个数据，称为权，这种图被称为网。

任意两个顶点都有路径相通的网，称为连通网。
</code></pre>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><ol>
<li>邻接矩阵法</li>
</ol>
<p>用一个一维数组来保存顶点的信息，用一个二维数组来保存与边相关的信息。</p>
<pre><code>在无向图中，我们用0表示两个顶点间没有边，1表示这两个顶点间的边存在。
</code></pre>
<p><img src="/2024/06/06/graph/3.jpg" alt="图-邻接矩阵法的简单示例（无向图）"><br>    在有向图中，我们为每一条边都加入一个权。用无穷远表示两个顶点之间没有有效的边。<br><img src="/2024/06/06/graph/4.jpg" alt="图-邻接矩阵法的例子（带权的有向图）"></p>
<p>需要注意的是：邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费。<br>2. 邻接表法</p>
<p>对于边的数目相对于顶点较少的图，使用邻接表。</p>
<pre><code>无向图的表示：
</code></pre>
<p><img src="/2024/06/06/graph/5.jpg" alt="图-无向图的邻接表法"><br>    有向图的表示（由于有向图的弧的方向性，我们需要用两个邻接表来表示一个有向图。一个邻接表，存放从这个顶点指向外部的弧形成的图，另外一个存放指向这个顶点的弧形成的图）：<br><img src="/2024/06/06/graph/6.jpg" alt="图-有向图的邻接表"></p>
<p>记录顶点指向外部的图时，叫做邻接表。记录指向该顶点的弧时，叫做逆邻接表。</p>
<h2 id="图的搜索算法"><a href="#图的搜索算法" class="headerlink" title="图的搜索算法"></a>图的搜索算法</h2><p><img src="/2024/06/06/graph/7.jpg" alt="图-示例图"></p>
<ol>
<li>深度优先搜索（DFS）</li>
</ol>
<p>如上图<br>随便选择一个顶点，比如 0。从 0 开始，随便选择一个与 0 邻接的顶点 1 ，继续寻找和 1 邻接的顶点 3 ，继续选择与 3 邻接的顶点 4 。4 没有其他邻接的顶点了，于是我们返回 3 ，3 还有另外一个 邻接的顶点 2 。2 本来就没有邻接顶点（考虑弧的方向），于是我们继续返回 3 。此时 3 也没有未被标记的邻接顶点了，我们返回 1 ，同理，返回到 0 。这是运气比较好的状态，从这个顶点开始，深度优先搜索，就遍历了整个图。</p>
<p>那么，如果从 2 开始，2 是没有邻接顶点的（考虑到弧的方向），于是 2 会被直接标记为 已遍历。但此时图没有被遍历，我们需要寻找另一个没被标记的顶点，再一次开始深度优先搜索，直到整个图都被遍历。</p>
<p>&#x2F;* 这里是的DFS是把图（邻接矩阵实现）遍历了一遍 *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="keyword">struct</span> Graph* G, <span class="type">int</span>* visited, <span class="type">int</span> index)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[index]);</span><br><span class="line">	visited[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vex_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;arcs[index][i] == <span class="number">1</span> &amp;&amp; !visited[i])</span><br><span class="line">			DFS(G, visited, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>广度优先搜索</li>
</ol>
<p>如上图<br>随便选择一个顶点，比如 0 。 从 0 开始 ，0 的 所有邻接顶点为 { 1，2 }，2 的临界点合集为空，观察 1 。1的邻接点合集为 { 3 } ，观察 3 ，3 的邻接点合集为 { 4 } （ 2已经被遍历过了所以不需要考虑 ）。此时没有未被遍历的点了，广度优先搜索结束。</p>
<p>如果选择顶点 2 ，从 2开始， 2 的邻接点合集为空。那么继续选择另一个未被遍历的邻接点，比如 0 ，再次开始广度优先搜索，直到遍历整个图。</p>
<p>&#x2F;* 这里是的BFS是把图（邻接矩阵实现）遍历了一遍，另外借助了队列来实现 *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="keyword">struct</span> Graph* G, <span class="type">int</span>* visited, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[index]);</span><br><span class="line">	visited[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>* <span class="title">Q</span> =</span> init_queue();</span><br><span class="line">	enqueue(Q, index);</span><br><span class="line">	<span class="keyword">while</span> (!is_empty(Q)) &#123;</span><br><span class="line">		<span class="type">int</span> i = dequeue(Q);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vex_num; j++)</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;arcs[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[j]);</span><br><span class="line">				visited[j] = <span class="number">1</span>;</span><br><span class="line">				enqueue(Q, j);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>拓扑排序</li>
</ol>
<p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。</p>
<p>对一个有向无环图进行拓扑排序有一个可以依照的方法，我们举个例子：<br>对下图的拓扑序列，我们找到其中任意一个没有前驱的顶点（没有以他为中点的弧的顶点），提取它放在新序列的第一个位置，然后删掉和这个顶点连接的所有弧。然后继续找此时没有前驱的顶点，重复操作直到所有顶点都被放入序列。</p>
<p><img src="/2024/06/06/graph/8.jpg" alt="图-拓扑排序方法示例"></p>
<p>对于图中的例子</p>
<ul>
<li>①我们发现V6是没有前驱的，提取出来，然后删掉V6连接的边。新序列：V6</li>
<li>②继续查看，我们发现V1也是没有前驱的。提取V1，删掉V1连接的边。新序列：V6-V1</li>
<li>③提取V4，删除边，新序列：V6-V1-V4</li>
<li>④提取V3，删除边，新序列：V6-V1-V4-V3</li>
<li>⑤提取V2，提取V5，新序列：V6-V1-V4-V3-V2-V5，也是最终这个图的一个拓扑排序序列。</li>
</ul>
<p>很明显，这个拓扑排序的结果不是唯一的，比如第一步可以先提取V1，最后一步可以先提取V5……但是他们的结果都是满足拓扑排序的要求的。</p>
<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><pre><code>**生成树**：从一个连通图中拆出一棵连通子图，它包含了所有的顶点，但只保留了足以构成一棵树的边（N-1条边，N为顶点个数）

**最小生成树**：对于连通网而言的，所有边的代价之和最小（权的总和最小）的生成树，就是最小生成树
</code></pre>
<p><img src="/2024/06/06/graph/9.jpg" alt="图-一个连通网和它的最小生成树"></p>
<ol>
<li>Prim算法</li>
<li>Kruskal算法</li>
</ol>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><pre><code>最短路径：两个点之间，权值的和最小的路径就是最短路径。
</code></pre>
<ol>
<li>Dijkstra算法</li>
<li>Floyd算法</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最全|《人月神话》书摘，看这一篇就够了</title>
    <url>/2024/06/06/tmmm/</url>
    <content><![CDATA[<h1 id="最全-《人月神话》书摘，看这一篇就够了"><a href="#最全-《人月神话》书摘，看这一篇就够了" class="headerlink" title="最全|《人月神话》书摘，看这一篇就够了"></a>最全|《人月神话》书摘，看这一篇就够了</h1><p>什么叫“人月神话”？</p>
<p>人是程序员，月是时间，，如果1人干10个月如果等同10人干1个月，那就成神话。</p>
<h1 id="001-焦油坑"><a href="#001-焦油坑" class="headerlink" title="001 焦油坑"></a>001 焦油坑</h1><p>过去几十年的大型系统开发就犹如一个焦油坑，很多大型动物在其中剧烈挣扎，他们中大多数开发出了可运行的系统–不过，其中只有非常少数的项目满足了目标、时间进度和预算的要求。</p>
<p>各种团队，大型的和小型的，庞杂的和精干的，一个接一个淹没在了焦油坑中。表面上看起来好像没有任何一个单独的问题会导致困难，每个都能被解决，但是当它们相互纠缠和累积在一起的时候，团队的行动就会变得越来越慢且很难看清问题的本质。</p>
<h1 id="002-人月神话"><a href="#002-人月神话" class="headerlink" title="002 人月神话"></a>002 人月神话</h1><p>缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来影响还大。</p>
<p>我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。</p>
<p>向软件项目中增派人手从三个方面增加了项目必要的总体工作量：</p>
<pre><code>任务重新分配本身和所造成的工作中断；

培训新人员；

额外的相互沟通。
</code></pre>
<p>关于进度安排，我的经验是为1&#x2F;3计划、1&#x2F;6编码、1&#x2F;4构件测试以及1&#x2F;4系统测试。</p>
<p>Brook法则：向进度落后的项目中增加人手，只会使进度更加落后。</p>
<p>特别需要指出的是，不为系统测试安排足够的时间简直就是一场灾难。</p>
<p>在现实情况中，一旦开发团队观察到进度的偏差，总是倾向于对任务进行削减。当项目延期所导致的后续成本非常高时，这常常是唯一可行的方法。</p>
<h1 id="003-外科手术队伍"><a href="#003-外科手术队伍" class="headerlink" title="003 外科手术队伍"></a>003 外科手术队伍</h1><p>小型、精干队伍是最好的–尽可能的少。</p>
<p>需要协作沟通的人员的数量影响着开发成本，因为成本的主要组成部分是相互的沟通和交流，以及更正沟通不当所引起的不良结果（系统调试）。</p>
<p>Mills建议大型项目的每一个部分由一个团队解决，但是该队伍以类似外科手术的方式组建，而并非一拥而上。</p>
<p>一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法–既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</p>
<h1 id="004-贵族专制、民主政治和系统设计"><a href="#004-贵族专制、民主政治和系统设计" class="headerlink" title="004 贵族专制、民主政治和系统设计"></a>004 贵族专制、民主政治和系统设计</h1><p>为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统，哪怕它们其实包含着许多很好的设计。</p>
<p>同工作的水平分割相比，垂直划分从根本上大大减少了劳动量，结果是使交流彻底地简化，概念完整性得到大幅提高。</p>
<h1 id="005-画蛇添足"><a href="#005-画蛇添足" class="headerlink" title="005 画蛇添足"></a>005 画蛇添足</h1><p>一种普遍倾向是过分地设计第二个系统，向系统添加很多修饰功能和想法，它们曾在第一个系统中被小心谨慎地推迟了。</p>
<p>实际情况中，尽早交流和持续沟通能使结构师有较好的成本意识，以及使开发人员获得对设计的信心，并且不会混淆各自的责任分工。</p>
<p>面对估算过高的难题，结构师有两个选择：削减设计或者建议成本更低的实现方法–挑战估算的结果</p>
<h1 id="006-贯彻执行"><a href="#006-贯彻执行" class="headerlink" title="006 贯彻执行"></a>006 贯彻执行</h1><p>即使是大型的设计团队，设计结果也必须由一个或两个人来完成，以确保这些决定是一致的。</p>
<p>允许体系结构师对实现人员的询问做出电话应答解释是非常重要的，并且必须进行日志记录和整理发布。</p>
<p>对于存有疑问的实现人员，应鼓励他们打电话询问相应的结构师，而不是一边自行猜测一边工作，这是一项很基本的措施。</p>
<h1 id="007-为什么巴比伦塔会失败？"><a href="#007-为什么巴比伦塔会失败？" class="headerlink" title="007 为什么巴比伦塔会失败？"></a>007 为什么巴比伦塔会失败？</h1><p>巴比伦塔项目的失败是因为缺乏交流，以及交流的结果–组织。</p>
<p>“因为左手不知道右手在做什么，从而进度灾难、功能的不合理和系统缺陷纷纷出现。</p>
<p>随着工作的进行，许多小组慢慢地修改自己程序的功能、规模和速度，他们明确或者隐含地更改了一些有效输入和输出结果用法上的约定，而因此给其他部分引发了BUG。</p>
<p>解决方案：</p>
<p>团队应该以尽可能多的方式进行相互之间的交流：非正式、常规项目会议，会上进行简要的技术陈述、共享的正式项目工作手册。举行常规项目会议，会议中，团队一个接一个地进行简要的技术陈述。这种方式非常有用，能澄清成百上千的细小误解。</p>
<p>制定项目工作手册，并实时记录变更：首先，必须在页面上标记发生改变的文本，例如，使用页边上的竖线标记每行变化的文字。第二，分发的变更页附带独立的总结性文字，对变更的重要性以及批注进行记录。</p>
<h1 id="008-胸有成竹"><a href="#008-胸有成竹" class="headerlink" title="008 胸有成竹"></a>008 胸有成竹</h1><p>编码大约只占了问题的六分之一左右，编码估计或者比率的错误可能会导致不合理的荒谬结果。</p>
<p>对常用编程语句而言。生产率似乎是固定的。这个固定的生产率包括了编程中需要注释，并可能存在错误的情况.</p>
<p>使用适当的高级语言，编程的生产率可以提高5倍。</p>
<h1 id="009-削足适履"><a href="#009-削足适履" class="headerlink" title="009 削足适履"></a>009 削足适履</h1><p>在大型的团队中，各个小组倾向于不断地局部优化，以满足自己的目标，而较少考虑队用户的整体影响。这种方向性的问题是大型项目的主要危险。</p>
<p>为了满足目标，每个人都在局部优化自己的程序，很少会有人停下来，考虑一下对客户的整体影响。</p>
<p>培养开发人员从系统整体出发、面向用户的态度是软件编程管理人员最重要的职能。</p>
<h1 id="010-提纲挈领"><a href="#010-提纲挈领" class="headerlink" title="010 提纲挈领"></a>010 提纲挈领</h1><p>如果要制造一台机器，哪些是关键的文档呢？</p>
<p>目标：定义待满足的目标和需要，定义迫切需要的资源、约束和优先级。</p>
<p>首先，书面记录决策是必要的。只有记录下来，分歧才会明朗，矛盾才会突出。项目经理常常会不断发现，许多理应被普遍认同的策略，完全不为团队的一些成员所知。每个文档本身就可以作为检查列表或者数据库。</p>
<p>项目经理的基本职责是使每个人都向着相同的方向前进。项目经理的主要日常工作是沟通，而不是做出决定；文档使各项计划和决策在整个团队范围内得到交流。</p>
<p>通过周期性的回顾，他能清楚项目所处的状态，以及哪些需要重点进行更改和调整。</p>
<h1 id="011-未雨绸缪"><a href="#011-未雨绸缪" class="headerlink" title="011 未雨绸缪"></a>011 未雨绸缪</h1><p>变更的客观需要</p>
<p>对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。</p>
<p>用户的实际需要和用户感觉会随着程序的构建、测试和使用而变化。</p>
<p>软件产品易于掌握的特性和不可见性，导致了它的构建人员（特别容易）面临着永恒的需求变更。</p>
<p>目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。</p>
<p>为变更计划组织结构</p>
<p>当系统发生变化时，管理结构也需要进行调整。只要管理人员和技术人才的天赋允许，老板必须对他们的能力培养给予极大的关注，使管理人员和技术人才具有互换性。</p>
<p>为什么缺陷不能更彻底地被修复？</p>
<p>首先，看上去很轻微的错误，似乎仅仅是局部操作上的失败，实际上却是系统级别的问题，通常这不是很明显。</p>
<p>设计实现的人员越少、接口越少，产生的错误也就越少。</p>
<p>所有修改都倾向于破坏系统的架构，增加了系统的混乱程度。用在修复原有设计上瑕疵的工作量越来越少，而早期维护活动本身的漏洞所引起修复工作越来越多。</p>
<p>随着时间的推移，系统变得越来越无序，修复工作迟早会失去根基 ，尽管理论上系统一直可用，但实际上，整个系统已经面目全非，无法再成为下一步进展的基础。</p>
<p>机器在变化，配置在变化，用户的需求在变化，所以现实系统不可能永远可用。崭新的、对于原有系统的重新设计是完全必要的。</p>
<h1 id="012-干将莫邪"><a href="#012-干将莫邪" class="headerlink" title="012 干将莫邪"></a>012 干将莫邪</h1><p>每个编程人员也保留着编辑器、排序、内存信息转储、磁盘实用程序等工具。 这种方法对软件项目来说是愚蠢的。首先，项目的关键问题是沟通，个性化的工具妨碍–而不是促进沟通。</p>
<p>交互式编程</p>
<p>MIT的Multics项目的成果之一，是它对软件编程系统开发的贡献。在那些系统编程所关注的方面，Multics（以及后续系统，IBM的TSS）和其他交互式计算机系统在概念上有很大的不同：多个级别上数据和程序的共享和保护，可延伸的库管理，以及协助终端用户共同开发的设施。我确信在某些应用上，批处理系统决不会被交互式系统所取代。</p>
<h1 id="013-整体部分"><a href="#013-整体部分" class="headerlink" title="013 整体部分"></a>013 整体部分</h1><p>许许多多的失败完全源于那些产品未精确定义的地方。</p>
<p>“细致的功能定义、详细的规格说明、规范化的功能描述说明以及这些方法的实施，大大减少了系统中必须查找的bug数量。 注: 需求文档越详细，bug越少</p>
<p>在编写任何代码之前，规格说明必须提交给测试小组，以详细地检查说明的完整性和明确性 注: 需求文档给测试过一遍</p>
<p>他将程序开发划分成体系结构设计、设计实现和物理编码实现，每个步骤可以使用自顶向下的方法很好地实现。</p>
<p>好的自顶向下设计从几个方面避免了bug。</p>
<p>首先，清晰的结构和表达方式更容易对需求和模块功能进行精确的描述。</p>
<p>其次，模块分割和模块独立性避免了系统级的bug。</p>
<p>另外，细节的隐藏使结构上的缺陷更加容易识别。</p>
<p>最后，设计在每个精化步骤的层次上是可以测试的，所以测试可以尽早开始，并且每个步骤的重点可以放在合适的级别上。</p>
<p>一些糟糕的系统往往就是试图挽救一个基础很差的设计，而对它添加了很多表面装饰般的补丁。自顶向下的方法减少了这样的企图。</p>
<h1 id="014-祸起萧墙"><a href="#014-祸起萧墙" class="headerlink" title="014 祸起萧墙"></a>014 祸起萧墙</h1><p>当人们听到某个项目的进度发生了灾难性偏离时，可能会认为项目一定是遭受了一系列重大灾难。然而，通常灾祸来自白蚁的肆虐，而不是龙卷风的侵袭。</p>
<h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>里程碑的选择只有一个原则，那就是，里程碑必须是具体的、特定的、可度量的事件，能够进行清晰定义。</p>
<p>例如：”结构师和实现人员签字认可的规格说明”，”100%源代码编制完成，纸带打孔完成并输入到磁盘库”，”测试通过了所有的测试用例”。</p>
<p>如果里程碑很模糊，老板就常常会得到一份与实际情况不符的报告。</p>
<p>慢性进度偏离是士气杀手。[Microsoft的Jim McCarthy说：”如果你错过了一个最终期限（deadline），确保制订下一条deadline</p>
<p>如果在某项活动开始之前就着手估计，并且每两周进行一次仔细的修订，根据实际情况动态调整时间。当里程碑没有正确反映损失的时间，并对人们形成误导，以致事态无法挽回的时候，它会彻底碾碎小组的士气。</p>
<h3 id="保持进度透明可见"><a href="#保持进度透明可见" class="headerlink" title="保持进度透明可见"></a>保持进度透明可见</h3><p>一线经理的利益和老板的利益是内在冲突的。一线经理担心如果汇报了问题，老板会采取行动,这些行动会取代经理的作用，降低自己的威信，搞乱了其他计划。所以，只要项目经理认为自己可以独立解决问题，他就不会告诉老板。</p>
<p>有两种掀开毯子把污垢展现在老板面前的方法，它们必须都被采用。</p>
<ol>
<li><p>一种是减少角色冲突和鼓励状态共享<br>  减少角色的冲突。老板必须规范自己，不对项目经理可以解决的问题做出反应。当项目经理了解到老板收到项目报告之后不会惊慌，或者不会越俎代庖时，他就逐渐会提交真实的评估结果。</p>
</li>
<li><p>另一种是猛地拉开地毯<br>猛地拉开地毯。不论协作与否，拥有能了解状态真相的评审机制是必要的。PERT图以及频繁的里程碑是这种评审的基础。大型项目中，可能需要每周对某些部分进行评审，大约一个月左右进行整体评审。</p>
</li>
<li><p>没有银弹软件工程中的根本和次要问题<br>没有任何技术或管理上的进展，能够独立地许诺十年内使生产率、可靠性或简洁性获得数量级上的进步。因为软件有无法规避的特性：复杂度、一致性、可变性、不可见性。</p>
</li>
</ol>
<h3 id="产品复杂度："><a href="#产品复杂度：" class="headerlink" title="产品复杂度："></a>产品复杂度：</h3><p>由于复杂度，团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；</p>
<p>由于复杂度，列举和理解所有可能的状态十分困难，影响了产品的可靠性；</p>
<p>由于函数的复杂度，函数调用变得困难，导致程序难以使用；</p>
<p>由于结构性复杂度，程序难以在不产生副作用的情况下用新函数扩充；由于结构性复杂度，造成很多安全机制状态上的不可见性。</p>
<p>复杂度不仅仅导致技术上的困难，还引发了很多管理上的问题。它使全面理解问题变得困难，从而妨碍了概念上的完整性；它使所有离散出口难以寻找和控制；它引起了大量学习和理解上的负担，使开发慢慢演变成了一场灾难。</p>
<h3 id="软件可变性："><a href="#软件可变性：" class="headerlink" title="软件可变性："></a>软件可变性：</h3><p>软件实体经常会遭受到持续的变更压力</p>
<p>现实工作中，经常发生两种情况。</p>
<p>当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。</p>
<p>其次，软件一定是在某种计算机硬件平台上开发，成功软件的生命期通常比当初的计算机硬件平台要长。即使不是更换计算机，则有可能是换新型号的磁盘、显示器或者打印机。软件必须与各种新生事物保持一致。</p>
<h3 id="软件不可见性："><a href="#软件不可见性：" class="headerlink" title="软件不可见性："></a>软件不可见性：</h3><p>软件是不可见的和无法可视化的。 其中的秘密就是逐步发育成长，而不是一次性搭建。</p>
<p>软件开发是一件棘手的事情，并不会有魔术般的解决方案，现在是从业者研究和分析革命性进展的时刻，而不是等待或希望它的出现。</p>
<p>现在有可能可以在软件生产率上取得逐步的进展，而不是等待不可能到来的大突破。</p>
<p><strong>转载至<a href="https://zhuanlan.zhihu.com/p/27521161">https://zhuanlan.zhihu.com/p/27521161</a> ，有改动</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>人月神话</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2024/06/06/greedy/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><blockquote>
<p>每一步在选择中，都采取当前状态下的最优选择，即做到了局部最优，通过这一列的局部最优选择，最终得到了全局最优解。</p>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="排队打水问题"><a href="#排队打水问题" class="headerlink" title="排队打水问题"></a>排队打水问题</h3><blockquote>
<p><strong>题目描述</strong><br>    有n个人排队到r个水龙头去打水，他们装满水桶的时间t1,t2,…,tnt1​,t2​,…,tn​ 为整数且各不相等，应如何安排他们的打水顺序才能使他们花费的总时间最少？<br>    每个人打水的时间 &#x3D; 排队的时间 + 实际打水的时间，本题假设一个人打好水，排在他后面的人接着打水的这个切换过程不消耗时间。<br>    比如，有2个人A和B，他们打水的时间分别是3和2 ，只有1个水龙头，这时，如果A先打水B后打水，那么A和B打水的时间分别为3、3+2（B排队3分钟）。<br>    因此，所有人打水的总时间就是每个人的打水时间及每个人的排队时间的总和。<br><strong>输入</strong><br>    第1行，两个整数n(1≤n≤5001≤n≤500)和r(1≤r≤100)。<br>    第2行,n个正整数t1,t2,…,tn,(1≤ti≤100)表示每个人装满水桶的时间。<br><strong>输出</strong><br>    1行，一个正整数，表示他们花费的最少总时间。<br><strong>样例</strong><br><strong>输入</strong><br><code>4 2 2 6 4 5</code><br><strong>输出</strong><br><code>    23</code></p>
</blockquote>
<p><strong>代码编写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">510</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> r, n, sum = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= r)</span><br><span class="line">			a[i] = a[i] + a[i - r];</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过河的最短时间"><a href="#过河的最短时间" class="headerlink" title="过河的最短时间"></a>过河的最短时间</h3><blockquote>
<p><strong>题目描述</strong><br>    在漆黑的夜里，NN 位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。<br>    不幸的是，NN 个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。<br>    如果各自单独过桥的话，NN 人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间<br>    问题是，如何设计一个方案，让这 NN 人尽快过桥，计算成绩这 NN 个人的最短过桥时间。<br>    比如：有四个人甲乙丙丁，他们过河需要的时间分别为，甲：11，乙：22，丙：55，丁：1010。<br>    第一种办法：最快的 22 个人先过桥，然后让跑的最快的人来回去接剩下的人：<br>    先让甲乙过去（22 分钟），甲回来（11 分钟），甲丙过去（55 分钟），甲回来（11 分钟），甲丁再过去（1010 分钟），总共需要 1919 分钟就可以让四个人都过去。<br>    第二种办法：让最慢的地 22 个人一起过桥，减少最慢的人在桥上的次数。<br>    先让甲乙过去（22 分钟），甲回来（11 分钟），丙丁过去（1010 分钟），乙回来（22 分钟），甲乙再过去（22 分钟），总共需要 1717 分钟可以让四个人都过去。<br>    那么最慢的时间就是需要 1717 分钟！<br><strong>输入</strong><br>    每组测试数据的第一行是一个整数 NN (1≤N≤10001≤N≤1000)，表示共有 NN 个人要过河。<br>    每组测试数据的第二行是 NN 个整数 SiSi​,表示这 NN 个人过河所需要花时间。(0&lt;Si≤1000&lt;Si​≤100)<br><strong>输出</strong><br>    所有人过河的最短时间。<br><strong>样例</strong><br><strong>输入</strong><br><code>4 1 2 5 10</code><br><strong>输出</strong><br><code>    17</code></p>
</blockquote>
<p><strong>代码编写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s[<span class="number">100001</span>], sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s, s + n);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        sum += <span class="built_in">min</span>(s[<span class="number">1</span>] * <span class="number">2</span> + s[<span class="number">0</span>] + s[n - <span class="number">1</span>], s[<span class="number">0</span>] * <span class="number">2</span> + s[n - <span class="number">2</span>] + s[n - <span class="number">1</span>]);</span><br><span class="line">        n -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        sum += s[<span class="number">0</span>] + s[<span class="number">1</span>] + s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        sum += s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        sum += s[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>linked-list</title>
    <url>/2024/06/06/linked-list/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>   链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 —— Wikipedia</p>
</blockquote>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表中最简单的一种是单向链表，或叫单链表，它包含两个域，一个数据域和一个指针域，指针域用于指向下一个节点，而最后一个节点则指向一个空值，如下图所示：</p>
<p><img src="/2024/06/06/linked-list/1.png" alt="图-单向链表"></p>
<p>单链表的遍历方向单一，只能从链头一直遍历到链尾。它的缺点是当要查询某一个节点的前一个节点时，只能再次从头进行遍历查询，因此效率比较低，而双向链表的出现恰好解决了这个问题。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = node;</span><br><span class="line">    L-&gt;data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;data; i++) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;next = n;</span><br><span class="line">    L-&gt;data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* preNode = L;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;data == data) &#123;</span><br><span class="line">            preNode-&gt;next = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L-&gt;data --;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;node = %d\n&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delete(L, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success delete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail delete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表也叫双面链表，它的每个节点由三部分组成：prev 指针指向前置节点，此节点的数据和 next 指针指向后置节点，如下图所示：</p>
<p><img src="/2024/06/06/linked-list/2.png" alt="图-双向链表"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next) &#123;</span><br><span class="line">        L -&gt; next -&gt; pre = node;</span><br><span class="line">        L -&gt; next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        L -&gt; next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    n -&gt; next = node -&gt; next;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next) &#123;</span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    tailInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">6</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表又分为单循环链表和双循环链表，也就是将单向链表或双向链表的首尾节点进行连接，这样就实现了单循环链表或双循环链表了，如下图所示：</p>
<p><a href="3.png">图-单循环链表</a></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* n = L;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)&#123;</span><br><span class="line">        n = n -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;</span><br><span class="line">    n -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* preNode = L;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)&#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">4</span>);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/06/linked-list/4.png" alt="图-双循环链表"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">* File Name: LoopDoubleLinkList.c</span></span><br><span class="line"><span class="comment">* Author: tyrantlucifer</span></span><br><span class="line"><span class="comment">* E-mail: tyrantlucifer@gmail.com</span></span><br><span class="line"><span class="comment">* Blog: https://tyrantlucifer.com</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = L;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    L -&gt; next -&gt; pre = node;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    n -&gt; next = L;</span><br><span class="line">    L -&gt; pre = n;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊的链表"><a href="#特殊的链表" class="headerlink" title="特殊的链表"></a>特殊的链表</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><pre><code>它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
</code></pre>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = L;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    L -&gt; next -&gt; pre = node;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    n -&gt; next = L;</span><br><span class="line">    L -&gt; pre = n;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>队列</strong></p>
<pre><code>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
</code></pre>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the node of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init queue</span></span><br><span class="line"><span class="comment"> * @return the head pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;pre = Q;</span><br><span class="line">    Q-&gt;next = Q;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enqueue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @param data the data you want to enqueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = Q;</span><br><span class="line">    node-&gt;pre = Q-&gt;pre;</span><br><span class="line">    Q-&gt;pre-&gt;next = node;</span><br><span class="line">    Q-&gt;pre = node;</span><br><span class="line">    Q-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not empty</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @return empty flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dequeue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @return the data of dequeue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* node = Q-&gt;next;</span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;</span><br><span class="line">        Q-&gt;next-&gt;pre = Q;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all item in queue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    Node* node = Q -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != Q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">循环队列</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of circular queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init queue</span></span><br><span class="line"><span class="comment"> * @return the pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in queue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not full</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return full flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not empty</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return empty flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enqueue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @param data the data you want to enqueue</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dequeue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return the data you want to dequeue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
