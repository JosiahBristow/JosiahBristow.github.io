<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为什么说10月24日是程序员的节日？</title>
    <url>/2024/06/06/1024/</url>
    <content><![CDATA[<h1 id="为什么说10月24日是程序员的节日？"><a href="#为什么说10月24日是程序员的节日？" class="headerlink" title="为什么说10月24日是程序员的节日？"></a>为什么说10月24日是程序员的节日？</h1><p>1024其实就是2的十次方，二进制计数的基本计量单位之一，是程序员每天都在打交道的数字。<br><img src="/2024/06/06/1024/1024.jpg" alt="1024"><br>1024也是一个很美妙的数字（别想歪），在数字世界里，1024BYTE(字节)&#x3D;1KB，1024 KB&#x3D;1MB，1024 MB&#x3D;1GB等等。<br>同时，1024MB是1GB，而1GB与1级谐音，也有一级棒的意思。<br>再加上每年10月24日是“联合国日”（1947年起），也是世界发展信息日<br>，所以这一天对于程序员来说非常有纪念意义。<br>国内许多互联网大厂都会在这个特殊的日子举办一些活动，纪念为公司和广大网友做出重大贡献的程序员们。</p>
]]></content>
      <tags>
        <tag>1024</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2024/06/06/backtracking/</url>
    <content><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。<br>例题</p>
</blockquote>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote>
<p>   给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>s<br>  <strong>输入</strong>:<br><code>n = 4, k = 2</code><br><strong>输出</strong>:<br><code>    [        [2,4],        [3,4],        [2,3],        [1,2],        [1,3],        [1,4],     ]</code></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> temp_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp_size + (n - cur + <span class="number">1</span>) &lt; k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp_size == k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            cout &lt;&lt; temp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp[temp_size++] = cur;</span><br><span class="line">    <span class="built_in">combination</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">    temp_size--;</span><br><span class="line">    <span class="built_in">combination</span>(cur + <span class="number">1</span>, n, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="type">int</span>[k];</span><br><span class="line">    <span class="built_in">combination</span>(<span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵找字符串"><a href="#矩阵找字符串" class="headerlink" title="矩阵找字符串"></a>矩阵找字符串</h2><blockquote>
<p> <strong>题目描述</strong><br>   在字符矩阵中查找给定字符串的所有匹配项<br>   给定一个M×N字符矩阵，以及一个字符串S，找到在矩阵中所有可能的连续字符组成的S的次数。所谓的连续字符，是指一个字符可以和位于其上下左右，左上左下，右上右下8个方向的字符组成字符串。用回溯法求解。<br>  <strong>输入描述</strong><br>    输入整数M,N，表示矩阵的行数和列数。<br>    接下来输入M行，每行输入N列个字符<br>    第M+1行输入一个需要在矩阵中查找的字符串S<br>    <strong>输出描述</strong><br>    共一行，表示测试用例中矩阵中字符串出现的次数<br><strong>样例输入</strong><br><code>5 5 D E M X B A O E P E D D C O D E B E D S C P Y E N CODE</code><br><strong>样例输出</strong><br><code>8      </code></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_path</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; martix, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos, <span class="type">int</span> cur_len, string tar)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (martix[pos.first][pos.second] != tar[cur_len])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cur_len++;</span><br><span class="line">        <span class="keyword">if</span> (tar.<span class="built_in">length</span>() == cur_len)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= pos.first + i &amp;&amp; pos.first + i &lt; martix.<span class="built_in">size</span>() &amp;&amp; <span class="number">0</span> &lt;= pos.second + j &amp;&amp; pos.second + j &lt; martix[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">                count += <span class="built_in">count_path</span>(martix, <span class="built_in">make_pair</span>(pos.first + i, pos.second + j), cur_len, tar);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">martix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; martix[i][j];</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            count += <span class="built_in">count_path</span>(martix, <span class="built_in">make_pair</span>(i, j), <span class="number">0</span>, s);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>BackTracking</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数与二次函数图像对比</title>
    <url>/2024/06/09/figure-diff/</url>
    <content><![CDATA[<h1 id="三角函数与二次函数图像对比"><a href="#三角函数与二次函数图像对比" class="headerlink" title="三角函数与二次函数图像对比"></a>三角函数与二次函数图像对比</h1><p>我们先来看一张图<br><img src="/2024/06/09/figure-diff/1.png" alt="图"><br>可以看到 $y &#x3D; \frac{4}{\pi^{2}}x^{2}-\frac{4}{\pi}x$ 的图像在 $[0, \pi]$ 区间内 与 $y&#x3D;\sin x$ 的图像在 $[\pi，2\pi]$ 区间内，形状极为相似，但通过仔细看图像，发现它们并不相同，但数学是一个严谨的学科，我们该如何证明呢？</p>
<h2 id="我的2种证明方法😀"><a href="#我的2种证明方法😀" class="headerlink" title="我的2种证明方法😀"></a>我的2种证明方法😀</h2><h3 id="方法1-–-定义法"><a href="#方法1-–-定义法" class="headerlink" title="方法1 – 定义法"></a>方法1 – 定义法</h3><blockquote>
<p>抛物线定义：平面内与一个定点 $F$ 和一条直线l 的距离相等的点的轨迹叫做抛物线，点 $F$ 叫做抛物线的焦点，直线 $l$ 叫做抛物线的准线，定点 $F$ 不在定直线上。它与椭圆、双曲线的第二定义相仿，仅比值（离心率 $e$）不同，当 $e&#x3D;1$ 时为抛物线，当 $0&lt;e&lt;1$ 时为椭圆，当 $e&gt;1$ 时为双曲线。</p>
</blockquote>
<p>根据定义很容易证明<br>$y &#x3D; \frac{4}{\pi^{2}}x^{2}-\frac{4}{\pi}x$ 的图像是抛物线 (<a href="https://zhidao.baidu.com/question/489205493320671732.html">二次函数是抛物线的证明</a>)，而$y&#x3D;\sin x$ 的图像不是</p>
<p>由此我们得出二者图像是不同的</p>
<h3 id="方法2-–-面积法"><a href="#方法2-–-面积法" class="headerlink" title="方法2 – 面积法"></a>方法2 – 面积法</h3><p>用定积分可算出 $y &#x3D; \frac{4}{\pi^{2}}x^{2}-\frac{4}{\pi}x$ 的图像 $[0, \pi]$ 区间内与 $x轴$ 围成的面积 </p>
<p>$<br>S_{1} &#x3D; \left|\int_{0}^{\pi} \frac{4}{\pi^{2}}x^{2}-\frac{4}{\pi}xdx\right| &#x3D;\left|\frac{4}{3\pi^{2}}x^{3} - \frac{2}{\pi}x^{2}|_{0}^{\pi}\right|&#x3D;\frac{2\pi}{3}<br>$</p>
<p>同样可算出$y&#x3D;\sin x$ 的图像在 $[\pi，2\pi]$ 区间内与 $x轴$ 围成的面积 </p>
<p>$<br>S_{2} &#x3D; \left|\int_{\pi}^{2\pi}\sin x\right| &#x3D; \left|\cos x|_{\pi}^{2\pi}\right|&#x3D;2<br>$</p>
<p>显然 $S_{1} !&#x3D; S_{2}$,因此二者图像是不同的,而且我们还得出$y &#x3D; \frac{4}{\pi^{2}}x^{2}-\frac{4}{\pi}x$ 的图像 $[0, \pi]$ 区间内与 $x轴$ 围成的面积比 $y&#x3D;\sin x$ 的图像在 $[\pi，2\pi]$ 区间内与 $x轴$ 围成的面积要大一些。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数学趣闻</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2024/06/06/git/</url>
    <content><![CDATA[<p><img src="/2024/06/06/git/1.png" alt="git"><br>Git[<a href="https://git-scm.com/]">https://git-scm.com/]</a></p>
<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h2><ol>
<li><strong>产看Git版本号</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git -v</span><br></pre></td></tr></table></figure>
或者<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li>
<li><strong>绑定用户信息</strong></li>
</ol>
<p>绑定用户名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;这里填你的名字&quot;</span></span><br></pre></td></tr></table></figure>
<p>绑定用户邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;这里填你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="正式使用Git"><a href="#正式使用Git" class="headerlink" title="正式使用Git"></a>正式使用Git</h2><ol>
<li>创建一个本地的Git项目仓库<br>clone别人的仓库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [项目地址]</span><br></pre></td></tr></table></figure>
创建版本库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment">#在你的项目文件夹下执行该指令Git将会在此文件夹下自动创建.git文件</span></span><br></pre></td></tr></table></figure></li>
<li><strong>提交文件</strong></li>
</ol>
<p>把代码提交到仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [文件名] <span class="comment">#执行该指令Git将把修改的代码添加到暂存区</span></span><br></pre></td></tr></table></figure>
<p>另外执行下面指令Git将把该目录下所有文件添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>放入仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;备注内容&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>查看记录</strong></li>
</ol>
<p>查看提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>若想查看更详细的信息，执行下面指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --static <span class="comment"># 查看提交时修改了哪些文件</span></span><br></pre></td></tr></table></figure>
<p>查看某次提交修改的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff [commit <span class="built_in">id</span>]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>代码回溯</strong><br>回溯到某个节点<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard [commit <span class="built_in">id</span>]</span><br></pre></td></tr></table></figure>
或者是<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [commit <span class="built_in">id</span>]</span><br></pre></td></tr></table></figure></li>
<li><strong>分支</strong><br>创建分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b [branch name]</span><br></pre></td></tr></table></figure>
查看分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
切换分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure>
合并分支<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge [branch name] <span class="comment">#执行该命令前先切换到你要合并的分支，如master分支</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法</title>
    <url>/2024/06/06/graph/</url>
    <content><![CDATA[<h1 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h1><h2 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h2><p><strong>图的概念</strong></p>
<blockquote>
<p> 一个图，由顶点(vertex)集和边(edge)集E组成。每一条边，连接了两个顶点，也就是一个点对。</p>
</blockquote>
<p><strong>有向图 无向图</strong></p>
<pre><code>如果点对之后是分次序的（比如仅限于从A点到B点），那么这这个图就是有向图(digraph)。此时我们可以把边叫做弧(arc)。

如果没有次序的差别，那么就是无向图。
</code></pre>
<p><img src="/2024/06/06/graph/1.jpg" alt="图-无向图和有向图"></p>
<p><strong>连通 强连通 弱连通</strong></p>
<pre><code>在上图的无向图中，由B到A，可以走B→A，也可以走B→C→A，还可以走B→C→D→A。

在上图的有向图中，由B到A，因为受到次序的限制，只能走B→A，B→C→A。

对于这样的线路，除了出发的顶点和结束的顶点之外，要求经过的顶点都不相同。这样这样的一组顶点序列就叫做一条路径。

对于无向图，如果任意两个顶点都能找到一条路径，这个无向图就是连通的。

对于有向图，在弧方向的限制下，如果任意两个顶点都能找到一条路径，这个有向图就是强连通的。如果去掉弧的指向才能满足条件，那么就是弱连通的。
</code></pre>
<p><strong>完全图</strong></p>
<pre><code>当一个图中，每一个点和任意另一个点之间都是点对（都由边连接），这个图就是完全图。
</code></pre>
<p><img src="/2024/06/06/graph/2.jpg" alt="图-完全图"></p>
<p><strong>网</strong></p>
<pre><code>网：图的边具有一定的意义，每条边都对应着一个数据，称为权，这种图被称为网。

任意两个顶点都有路径相通的网，称为连通网。
</code></pre>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><ol>
<li>邻接矩阵法</li>
</ol>
<p>用一个一维数组来保存顶点的信息，用一个二维数组来保存与边相关的信息。</p>
<pre><code>在无向图中，我们用0表示两个顶点间没有边，1表示这两个顶点间的边存在。
</code></pre>
<p><img src="/2024/06/06/graph/3.jpg" alt="图-邻接矩阵法的简单示例（无向图）"><br>    在有向图中，我们为每一条边都加入一个权。用无穷远表示两个顶点之间没有有效的边。<br><img src="/2024/06/06/graph/4.jpg" alt="图-邻接矩阵法的例子（带权的有向图）"></p>
<p>需要注意的是：邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费。<br>2. 邻接表法</p>
<p>对于边的数目相对于顶点较少的图，使用邻接表。</p>
<pre><code>无向图的表示：
</code></pre>
<p><img src="/2024/06/06/graph/5.jpg" alt="图-无向图的邻接表法"><br>    有向图的表示（由于有向图的弧的方向性，我们需要用两个邻接表来表示一个有向图。一个邻接表，存放从这个顶点指向外部的弧形成的图，另外一个存放指向这个顶点的弧形成的图）：<br><img src="/2024/06/06/graph/6.jpg" alt="图-有向图的邻接表"></p>
<p>记录顶点指向外部的图时，叫做邻接表。记录指向该顶点的弧时，叫做逆邻接表。</p>
<h2 id="图的搜索算法"><a href="#图的搜索算法" class="headerlink" title="图的搜索算法"></a>图的搜索算法</h2><p><img src="/2024/06/06/graph/7.jpg" alt="图-示例图"></p>
<ol>
<li>深度优先搜索（DFS）</li>
</ol>
<p>如上图<br>随便选择一个顶点，比如 0。从 0 开始，随便选择一个与 0 邻接的顶点 1 ，继续寻找和 1 邻接的顶点 3 ，继续选择与 3 邻接的顶点 4 。4 没有其他邻接的顶点了，于是我们返回 3 ，3 还有另外一个 邻接的顶点 2 。2 本来就没有邻接顶点（考虑弧的方向），于是我们继续返回 3 。此时 3 也没有未被标记的邻接顶点了，我们返回 1 ，同理，返回到 0 。这是运气比较好的状态，从这个顶点开始，深度优先搜索，就遍历了整个图。</p>
<p>那么，如果从 2 开始，2 是没有邻接顶点的（考虑到弧的方向），于是 2 会被直接标记为 已遍历。但此时图没有被遍历，我们需要寻找另一个没被标记的顶点，再一次开始深度优先搜索，直到整个图都被遍历。</p>
<p>&#x2F;* 这里是的DFS是把图（邻接矩阵实现）遍历了一遍 *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="keyword">struct</span> Graph* G, <span class="type">int</span>* visited, <span class="type">int</span> index)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[index]);</span><br><span class="line">	visited[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vex_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;arcs[index][i] == <span class="number">1</span> &amp;&amp; !visited[i])</span><br><span class="line">			DFS(G, visited, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>广度优先搜索</li>
</ol>
<p>如上图<br>随便选择一个顶点，比如 0 。 从 0 开始 ，0 的 所有邻接顶点为 { 1，2 }，2 的临界点合集为空，观察 1 。1的邻接点合集为 { 3 } ，观察 3 ，3 的邻接点合集为 { 4 } （ 2已经被遍历过了所以不需要考虑 ）。此时没有未被遍历的点了，广度优先搜索结束。</p>
<p>如果选择顶点 2 ，从 2开始， 2 的邻接点合集为空。那么继续选择另一个未被遍历的邻接点，比如 0 ，再次开始广度优先搜索，直到遍历整个图。</p>
<p>&#x2F;* 这里是的BFS是把图（邻接矩阵实现）遍历了一遍，另外借助了队列来实现 *&#x2F;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="keyword">struct</span> Graph* G, <span class="type">int</span>* visited, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[index]);</span><br><span class="line">	visited[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>* <span class="title">Q</span> =</span> init_queue();</span><br><span class="line">	enqueue(Q, index);</span><br><span class="line">	<span class="keyword">while</span> (!is_empty(Q)) &#123;</span><br><span class="line">		<span class="type">int</span> i = dequeue(Q);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vex_num; j++)</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;arcs[i][j] == <span class="number">1</span> &amp;&amp; !visited[j]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;vexs[j]);</span><br><span class="line">				visited[j] = <span class="number">1</span>;</span><br><span class="line">				enqueue(Q, j);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>拓扑排序</li>
</ol>
<p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。</p>
<p>对一个有向无环图进行拓扑排序有一个可以依照的方法，我们举个例子：<br>对下图的拓扑序列，我们找到其中任意一个没有前驱的顶点（没有以他为中点的弧的顶点），提取它放在新序列的第一个位置，然后删掉和这个顶点连接的所有弧。然后继续找此时没有前驱的顶点，重复操作直到所有顶点都被放入序列。</p>
<p><img src="/2024/06/06/graph/8.jpg" alt="图-拓扑排序方法示例"></p>
<p>对于图中的例子</p>
<ul>
<li>①我们发现V6是没有前驱的，提取出来，然后删掉V6连接的边。新序列：V6</li>
<li>②继续查看，我们发现V1也是没有前驱的。提取V1，删掉V1连接的边。新序列：V6-V1</li>
<li>③提取V4，删除边，新序列：V6-V1-V4</li>
<li>④提取V3，删除边，新序列：V6-V1-V4-V3</li>
<li>⑤提取V2，提取V5，新序列：V6-V1-V4-V3-V2-V5，也是最终这个图的一个拓扑排序序列。</li>
</ul>
<p>很明显，这个拓扑排序的结果不是唯一的，比如第一步可以先提取V1，最后一步可以先提取V5……但是他们的结果都是满足拓扑排序的要求的。</p>
<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><pre><code>**生成树**：从一个连通图中拆出一棵连通子图，它包含了所有的顶点，但只保留了足以构成一棵树的边（N-1条边，N为顶点个数）

**最小生成树**：对于连通网而言的，所有边的代价之和最小（权的总和最小）的生成树，就是最小生成树
</code></pre>
<p><img src="/2024/06/06/graph/9.jpg" alt="图-一个连通网和它的最小生成树"></p>
<ol>
<li>Prim算法</li>
<li>Kruskal算法</li>
</ol>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><pre><code>最短路径：两个点之间，权值的和最小的路径就是最短路径。
</code></pre>
<ol>
<li>Dijkstra算法</li>
<li>Floyd算法</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Graph</category>
      </categories>
      <tags>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2024/06/06/greedy/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><blockquote>
<p>每一步在选择中，都采取当前状态下的最优选择，即做到了局部最优，通过这一列的局部最优选择，最终得到了全局最优解。</p>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="排队打水问题"><a href="#排队打水问题" class="headerlink" title="排队打水问题"></a>排队打水问题</h3><blockquote>
<p><strong>题目描述</strong><br>    有n个人排队到r个水龙头去打水，他们装满水桶的时间t1,t2,…,tnt1​,t2​,…,tn​ 为整数且各不相等，应如何安排他们的打水顺序才能使他们花费的总时间最少？<br>    每个人打水的时间 &#x3D; 排队的时间 + 实际打水的时间，本题假设一个人打好水，排在他后面的人接着打水的这个切换过程不消耗时间。<br>    比如，有2个人A和B，他们打水的时间分别是3和2 ，只有1个水龙头，这时，如果A先打水B后打水，那么A和B打水的时间分别为3、3+2（B排队3分钟）。<br>    因此，所有人打水的总时间就是每个人的打水时间及每个人的排队时间的总和。<br><strong>输入</strong><br>    第1行，两个整数n(1≤n≤5001≤n≤500)和r(1≤r≤100)。<br>    第2行,n个正整数t1,t2,…,tn,(1≤ti≤100)表示每个人装满水桶的时间。<br><strong>输出</strong><br>    1行，一个正整数，表示他们花费的最少总时间。<br><strong>样例</strong><br><strong>输入</strong><br><code>4 2 2 6 4 5</code><br><strong>输出</strong><br><code>    23</code></p>
</blockquote>
<p><strong>代码编写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">510</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> r, n, sum = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= r)</span><br><span class="line">			a[i] = a[i] + a[i - r];</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过河的最短时间"><a href="#过河的最短时间" class="headerlink" title="过河的最短时间"></a>过河的最短时间</h3><blockquote>
<p><strong>题目描述</strong><br>    在漆黑的夜里，NN 位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。<br>    不幸的是，NN 个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。<br>    如果各自单独过桥的话，NN 人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间<br>    问题是，如何设计一个方案，让这 NN 人尽快过桥，计算成绩这 NN 个人的最短过桥时间。<br>    比如：有四个人甲乙丙丁，他们过河需要的时间分别为，甲：11，乙：22，丙：55，丁：1010。<br>    第一种办法：最快的 22 个人先过桥，然后让跑的最快的人来回去接剩下的人：<br>    先让甲乙过去（22 分钟），甲回来（11 分钟），甲丙过去（55 分钟），甲回来（11 分钟），甲丁再过去（1010 分钟），总共需要 1919 分钟就可以让四个人都过去。<br>    第二种办法：让最慢的地 22 个人一起过桥，减少最慢的人在桥上的次数。<br>    先让甲乙过去（22 分钟），甲回来（11 分钟），丙丁过去（1010 分钟），乙回来（22 分钟），甲乙再过去（22 分钟），总共需要 1717 分钟可以让四个人都过去。<br>    那么最慢的时间就是需要 1717 分钟！<br><strong>输入</strong><br>    每组测试数据的第一行是一个整数 NN (1≤N≤10001≤N≤1000)，表示共有 NN 个人要过河。<br>    每组测试数据的第二行是 NN 个整数 SiSi​,表示这 NN 个人过河所需要花时间。(0&lt;Si≤1000&lt;Si​≤100)<br><strong>输出</strong><br>    所有人过河的最短时间。<br><strong>样例</strong><br><strong>输入</strong><br><code>4 1 2 5 10</code><br><strong>输出</strong><br><code>    17</code></p>
</blockquote>
<p><strong>代码编写</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s[<span class="number">100001</span>], sum = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s, s + n);</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        sum += <span class="built_in">min</span>(s[<span class="number">1</span>] * <span class="number">2</span> + s[<span class="number">0</span>] + s[n - <span class="number">1</span>], s[<span class="number">0</span>] * <span class="number">2</span> + s[n - <span class="number">2</span>] + s[n - <span class="number">1</span>]);</span><br><span class="line">        n -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        sum += s[<span class="number">0</span>] + s[<span class="number">1</span>] + s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        sum += s[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        sum += s[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Greedy</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2024/06/06/linked-list/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>   链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 —— Wikipedia</p>
</blockquote>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表中最简单的一种是单向链表，或叫单链表，它包含两个域，一个数据域和一个指针域，指针域用于指向下一个节点，而最后一个节点则指向一个空值，如下图所示：</p>
<p><img src="/2024/06/06/linked-list/1.png" alt="图-单向链表"></p>
<p>单链表的遍历方向单一，只能从链头一直遍历到链尾。它的缺点是当要查询某一个节点的前一个节点时，只能再次从头进行遍历查询，因此效率比较低，而双向链表的出现恰好解决了这个问题。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = node;</span><br><span class="line">    L-&gt;data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;data; i++) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    n-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;next = n;</span><br><span class="line">    L-&gt;data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* preNode = L;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;data == data) &#123;</span><br><span class="line">            preNode-&gt;next = node-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L-&gt;data --;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;node = %d\n&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delete(L, <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success delete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail delete\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表也叫双面链表，它的每个节点由三部分组成：prev 指针指向前置节点，此节点的数据和 next 指针指向后置节点，如下图所示：</p>
<p><img src="/2024/06/06/linked-list/2.png" alt="图-双向链表"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;</span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next) &#123;</span><br><span class="line">        L -&gt; next -&gt; pre = node;</span><br><span class="line">        L -&gt; next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        L -&gt; next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    n -&gt; next = node -&gt; next;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next) &#123;</span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    tailInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">6</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表又分为单循环链表和双循环链表，也就是将单向链表或双向链表的首尾节点进行连接，这样就实现了单循环链表或双循环链表了，如下图所示：</p>
<p><a href="3.png">图-单循环链表</a></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* n = L;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)&#123;</span><br><span class="line">        n = n -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;</span><br><span class="line">    n -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* preNode = L;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)&#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">3</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">4</span>);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/06/linked-list/4.png" alt="图-双循环链表"></p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">* File Name: LoopDoubleLinkList.c</span></span><br><span class="line"><span class="comment">* Author: tyrantlucifer</span></span><br><span class="line"><span class="comment">* E-mail: tyrantlucifer@gmail.com</span></span><br><span class="line"><span class="comment">* Blog: https://tyrantlucifer.com</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = L;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    L -&gt; next -&gt; pre = node;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    n -&gt; next = L;</span><br><span class="line">    L -&gt; pre = n;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="特殊的链表"><a href="#特殊的链表" class="headerlink" title="特殊的链表"></a>特殊的链表</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><pre><code>它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
</code></pre>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of list node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init a link list</span></span><br><span class="line"><span class="comment"> * @return the head pointer of link list&#x27;s head</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L -&gt; data = <span class="number">0</span>;</span><br><span class="line">    L -&gt; pre = L;</span><br><span class="line">    L -&gt; next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s head</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data  the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node -&gt; data = data;</span><br><span class="line">    node -&gt; next = L -&gt; next;</span><br><span class="line">    node -&gt; pre = L;</span><br><span class="line">    L -&gt; next -&gt; pre = node;</span><br><span class="line">    L -&gt; next = node;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert item in link list&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to insert</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L) &#123;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    n -&gt; data = data;</span><br><span class="line">    n -&gt; pre = node;</span><br><span class="line">    n -&gt; next = L;</span><br><span class="line">    L -&gt; pre = n;</span><br><span class="line">    node -&gt; next = n;</span><br><span class="line">    L -&gt; data ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * delete item in link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> * @param data the data you want to delete</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = L -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data) &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L -&gt; data --;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in a link list</span></span><br><span class="line"><span class="comment"> * @param L the head pointer of link list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node != L)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();</span><br><span class="line">    headInsert(L, <span class="number">1</span>);</span><br><span class="line">    headInsert(L, <span class="number">2</span>);</span><br><span class="line">    headInsert(L, <span class="number">4</span>);</span><br><span class="line">    headInsert(L, <span class="number">5</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    tailInsert(L, <span class="number">6</span>);</span><br><span class="line">    tailInsert(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    delete(L, <span class="number">7</span>);</span><br><span class="line">    printList(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>队列</strong></p>
<pre><code>它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。
</code></pre>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the node of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init queue</span></span><br><span class="line"><span class="comment"> * @return the head pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;pre = Q;</span><br><span class="line">    Q-&gt;next = Q;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enqueue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @param data the data you want to enqueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = Q;</span><br><span class="line">    node-&gt;pre = Q-&gt;pre;</span><br><span class="line">    Q-&gt;pre-&gt;next = node;</span><br><span class="line">    Q-&gt;pre = node;</span><br><span class="line">    Q-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not empty</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @return empty flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dequeue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> * @return the data of dequeue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* node = Q-&gt;next;</span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;</span><br><span class="line">        Q-&gt;next-&gt;pre = Q;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all item in queue</span></span><br><span class="line"><span class="comment"> * @param Q the head pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span> &#123;</span><br><span class="line">    Node* node = Q -&gt; next;</span><br><span class="line">    <span class="keyword">while</span> (node != Q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);</span><br><span class="line">        node = node -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">循环队列</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * define the struct of circular queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * init queue</span></span><br><span class="line"><span class="comment"> * @return the pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print all items in queue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not full</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return full flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * judge queue is or not empty</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return empty flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enqueue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @param data the data you want to enqueue</span></span><br><span class="line"><span class="comment"> * @return success flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dequeue</span></span><br><span class="line"><span class="comment"> * @param Q the pointer of queue</span></span><br><span class="line"><span class="comment"> * @return the data you want to dequeue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main function</span></span><br><span class="line"><span class="comment"> * @return null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Data Structure</category>
        <category>Linked List</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《Just for fun》-Linux之父Linus的传奇人生</title>
    <url>/2024/06/06/linus/</url>
    <content><![CDATA[<h1 id="《Just-for-fun》-Linux之父Linus的传奇人生"><a href="#《Just-for-fun》-Linux之父Linus的传奇人生" class="headerlink" title="《Just for fun》-Linux之父Linus的传奇人生"></a>《Just for fun》-Linux之父Linus的传奇人生</h1><h2 id="Linus-的计算机启蒙"><a href="#Linus-的计算机启蒙" class="headerlink" title="Linus 的计算机启蒙"></a>Linus 的计算机启蒙</h2><p>1969年12月28日，Linus 出生于芬兰赫尔辛基，他从小就是一个书呆子，矮个子，读书不错，但是不擅长运动，不善社交。</p>
<p>Linus的外公是赫尔辛基大学的统计学教授，1981年Linus 11岁的时候，外公买回来一台Commodore vic-20计算机，用来在家进行统计学计算。Linus 就帮助外公输入他事先写在纸上的basic程序。一开始是机械的输入外公写好的程序，后来是根据计算机的使用手册，把示例程序敲出来。</p>
<p>然后Linus 对计算机的兴趣就一发不可收拾，买了很多计算机的书和杂志，然年后发现计算机是机器语言来控制的，于是他开始研究机器语言编写程序，在外公过世后，这台计算机归了Linus 所用，从此，他开始了更疯狂的计算机学习（玩电脑）。<br><img src="/2024/06/06/linus/Commodore-VIC-20-FL.jpg" alt="commodore vic-20"><br>在家玩电脑，熬通宵是常有的事情，别的男孩是躲在被窝里悄悄的阅读《花花公子》，他则是假装睡着，等妈妈走开在坐到电脑跟前。因为玩的太沉迷，他妈妈会和她的一些记者朋友们说，Linus 是个很好养的小孩，只要把他和一台电脑关在一个黑乎乎的小屋里，再时不时的丢一点面条进去就行。</p>
<p>Linus 的程序员气质也是从小养成的，小学的时候学校当时有好些女生想要得到他这位数学天才的辅导，他却都不理不睬的。到中学的时候，带女孩子回家辅导数学，就真的辅导数学，女生的暗示都没有听懂。</p>
<p>这就是程序员的注孤生buff吧，女生哪有计算机有意思。</p>
<h2 id="Linux操作系统的诞生"><a href="#Linux操作系统的诞生" class="headerlink" title="Linux操作系统的诞生"></a>Linux操作系统的诞生</h2><p>读高中的时候，因为数学特别好，拿了奖学金，加上日常攒钱和打工，Linus 花了2000美金，买了一台sinclairQL。</p>
<p>Linus 的操作系统之旅是从驱动程序开始的，他买了一个软盘控制器，但是自带的驱动程序特别差，所以他就自己写了一个，结果在写驱动的时候，发现了sinclair自带的Q-DOS操作系统的bug，于是他开始对操作系统进行反汇编，把操作系统的机器语言翻译为汇编语言，但是Q-DOS只有钩子机制可以加载自己的代码，系统本身不支持任何修改，这给年轻的Linus 埋下了做操作系统的种子。<br><img src="/2024/06/06/linus/sinclairQL.jpg" alt="sinclairQL"><br>Linus 充分诠释了什么叫我行我上</p>
<p>每个人都可能会遇到一本改变自己一生的书，对Linus 而言，改变他一生的书是安德鲁·坦尼鲍姆所著的《操作系统：设计与实现》。</p>
<p>这本书里阿姆斯特丹自由大学的教授坦尼鲍姆讨论了他为Unix操作系统编写的教学辅助工具-Minix操作系统。Minix是一个小型的Unix系统，是为了介绍Unix操作系统如何实现而做，也是最好入门Unix操作系统的代码示例。这本书让Linus 脱胎换骨，在操作系统领域达到了一个全新的高度，为他编写Linux解决了大量技术问题。</p>
<p>Linus 在学习Minix操作系统的过程中，对自带的终端仿真程序非常不满，于是自己写了一个。然后他不想在Minix系统里写，想要在无系统的裸硬件上写，来更好的理解计算机的执行原理。于是他需要知道cpu的工作原理，知道如何写入屏幕，如何读取键盘的输入，如何读写modem，这就是操作系统的雏形。Linus 用这个终端程序登入学校的电脑，查阅电子邮件，参加Minix新闻组的讨论，但是他还想上传和下载文件，于是还需要磁盘驱动程序和文件系统驱动，这是巨大的工作量。他的日程从此变成了编程-睡觉-编程-睡觉的循环，在过程中，这个终端越来越像操作系统，于是Linus 干脆决定把这个终端做成操作系统。</p>
<p>要做成操作系统，还有一个巨大的挑战，那就是要实现Posix规范，也就是Unix系统里的系统调用，有了这些系统api，其他Unix的程序就可以在这个操作系统上运行。Linus 在电子邮件新闻组里求助未果后，找到Sun公司Unix系统的用户手册，然后根据基本版的系统调用标准，开始自己实现这些功能。</p>
<p>同时他在电子邮件讨论组里的求助邮件，引起了赫尔辛基理工大学的助教阿里·克莱姆的注意，阿里为他提供了FTP站点，让Linus把他的操作系统代码可以共享出来。</p>
<p>Linus在开发到一定程度之后，决定把代码开源出去。在1991年9月17日，Linus把操作系统上传到FTP上，那个时候的Linux操作系统大概1w行左右，而现在Linux超过1000w行代码。</p>
<p>关于操作系统的命名，本来linus是打算叫freax，是发read，free，unix的合成词。但是阿里·莱姆克很讨厌这个名字，他挺喜欢另一个名字-Linux，也就是Linus的名字加上当时的操作系统命名习惯，结尾用x，Linux就此命名。<br><img src="/2024/06/06/linus/linux.jpg" alt="linux"></p>
<h2 id="使用GPL许可，Linux的商业价值全面释放"><a href="#使用GPL许可，Linux的商业价值全面释放" class="headerlink" title="使用GPL许可，Linux的商业价值全面释放"></a>使用GPL许可，Linux的商业价值全面释放</h2><p>在发布Linux后，Linus本打算就此洗手不干，因为已经完成了操作系统中最有意思的工作，对后续的内容失去了兴趣。但是意外发生了，他写的程序因为bug，覆盖了硬盘分区，整个Minix系统文件没了，他要做一个选择，重新安装Minix，或者放弃使用Minix，使用Linux。为了完善Linux系统，他决定以后就用自己的系统，需要什么Minix的功能，就自己写到Linux上，于是他继续不断更新。</p>
<p>与此同时，ftp上的Linux操作系统代码被人注意到，开始有人下载使用，并给与了很多反馈：新增功能，修复bug，支持新硬件等。Linus不断地满足这些用户的要求，其中最重要的是分页到磁盘功能，也就是现在操作系统必备的虚拟内存功能。虚拟内存可以在计算机内存不足的时候用硬盘来代替内存。这个程序让Linux名声鹊起，因为那个年代内存还是1mb，2mb的规格，非常捉襟见肘，为了在低配置的情况下运行程序，这个功能作用巨大，于是越来越多的人被这个功能吸引，来使用Linux。</p>
<p>在当时的极客圈，有个不成文的规定：下载软件，最好给软件作者汇上10美元。但是Linus拒绝了，虽然他手头很紧，有5000美金的学生贷款，分期的电脑费用也没有还完，但是他觉得自己是在其他人的基础上做出linux，而用户的反馈可以改良Linux，所以实在不好意思索要报酬。</p>
<p>但是Linus一时心血来潮，半开玩笑的向Linux用户索要明信片，结果几百张明信片从日本，新西兰，荷兰，美国等地蜂拥而至。这些全世界各地的用户反馈让Linus受到了极大的鼓舞，让他决定继续做下去。</p>
<p>Linux越来越流行，Linus面临着另一个挑战，就是软件版权协议。Linus因为个人的道德洁癖和想要更好的发展Linux，一直要求Linux免费且开源，在版权说明中要求任何人只要不用于出售，都可以免费使用Linux操作系统，而且对Linux做的改进必须开源。</p>
<p>但是慢慢的，有人开始把Linux下载到软盘上，然后卖给别人收取报酬，这让linus好好反省了“Linux是非卖品”这个原则。通过反复的思考和调研，他决定使用GPL许可证。<br><img src="/2024/06/06/linus/GPL.jpg" alt="GPL"><br>GPL许可证是通用公共版权许可证，最早是为GNU项目所写，主要内容是:任何遵守条款和条件的被授证人员都有权修改作品，以及复制和重新分发作品或任何派生版本。被许可人被允许为此服务收取费用，或无偿。</p>
<p>简单来说，Linux本身是开源和免费的，但是也可以有人依靠卖Linux的拷贝和自己修改的Linux赚钱，但是基于Linux修改得到的系统，也必须符合GPL协议，而且提供给使用者的时候，必须提供源代码。</p>
<p>GPL带来的，是Linux系统可以被人用于商业用途，比如你可以自己做一个Linux发行版本，卖给你的客户，愿意卖多贵都可以，然后你的客户得到了全部的源代码，他可以自己编译，自己修改你的系统，做成自己的Linux发行版，因为GPL规定客户可以随意使用这个源代码。那么你怎么赚钱呢？其实很简单，系统会不断的更新，安全补丁或者新功能，这些更新你的客户也是需要的。所以很多时候，你不是靠卖拷贝赚钱，而是卖维护Linux，提供功能，补丁，咨询服务等来赚钱，变成订阅业务模式。这也是现在Redhat公司主营业务模式。</p>
<p>使用GPL，是Linux操作系统发展过程中的另一个里程碑，因为有很多公司和个人，可以依靠Linux赚钱了，有利益相关，Linux才能发展的更好</p>
<h2 id="乘上开源软件的东风，Linux大器终成"><a href="#乘上开源软件的东风，Linux大器终成" class="headerlink" title="乘上开源软件的东风，Linux大器终成"></a>乘上开源软件的东风，Linux大器终成</h2><p>接下来Linux进入了发展的快车道，92年第一代x视窗系统被一个叫奥瑞斯特·扎布罗斯基的黑客，移植到Linux系统，并因此实现了socket层。这样Linux有了图形界面，Linus更是从中嗅出了机会，用sokcet可以实现联网能力，于是他花了2年，实现了Linux的网络功能，让Linux系统更加成熟。Linux邮件新闻组知名度也越来越高，Linus找到5个志同道合的高手，组成了Linux核心小组，通过开放源代码，Linus做仲裁的模式，Linux越来越成熟。</p>
<p>到93年，Linus成为了大学助教，开始上课，而他带的第一批学生中，有一个女生给他发邮件邀他约会，她是Linus遇到的第一个通过互联网的方式接近他的女人，于是Linus把她娶回了家。（Linus的原话就是这样）</p>
<p>接下来就是Linus的人生高光时刻，Linux1.0版本发布，因为Linux已经非常知名，所以赫尔辛基大学非常支持，主动将计算机系的大礼堂借给Linus，而且这次发布会，会在芬兰的电视上进行直播，这是他生平第一次有机会在电视上看到自己。<br><img src="/2024/06/06/linus/linus.jpg" alt="linus"><br>96年，Linus拿到了硕士学位，收到朋友邀请，准备去美国考察工作机会。作为业界知名技术大神，Linus没有准备简历，就收到了5个offer，硅谷公司全美达，Redhat红帽，芬兰的电视公司，DEC等。最后Linus选择了全美达。</p>
<p>全美达在当时是整个硅谷最神秘的公司，没人知道这家公司是做什么的，公司所有员工都签署了保密协议，不能对外透露自己的工作内容。这份神秘保持到了2000年，全美达推出了一种全新架构的cpu—Crusoe，这种cpu最大的特点是低功耗，而且完全兼容x86指令集，依靠全新架构的cpu，全美达在2000年11月IPO成功，成为互联网泡沫破裂前最后一家上市的科技巨头。但是因为AMD和Intel的竞争，以及自己的研发出现问题，09年全美达被收购，同年收购全美达的novafora因为财务问题和经营不善破产，全美达从此成为历史。<br><img src="/2024/06/06/linus/CPUCrusoe.jpg" alt="CPUCrusoe"><br>全美达兼容x86指令集用了一个很惊人的方法，用软件翻译x86指令，转化为自己cpu的指令，而这个核心的x86解释程序，就是linus加盟后编写的。</p>
<p>1998年，网景公司开放了mozila项目的源代码，这就是后来的firefox火狐浏览器的前身。2个月后，Sun公司也加入开源运动，成为第一个加盟Linux国际组织的硬件设备商，它们的服务器将支持使用Linux系统。（Sun公司当年还是类似IBM的主要销售服务器的公司，当然sun最大的贡献还是开发了java语言，多谢祖师爷赏饭吃，不过Sun后来被Oracle收购，现在也已经是历史名词了。）IBM随后加入，接下来是当年的数据库三巨头之一的Informix对linux系统开放数据库接口，Oracle也快速跟进，开放数据库接口。</p>
<p>随着越来越多大公司的支持和技术人员的重视，Linux开始在服务器领域攻城略地，成为最受欢迎的服务器操作系统。</p>
<h2 id="财务自由"><a href="#财务自由" class="headerlink" title="财务自由"></a>财务自由</h2><p>1999年8月11日，Redhat红帽挂牌上市，Redhat是专门Linux发行版和企业服务的公司。Redhat给了Linus一些股票期权，在上市的时候，Linus突然意识到，自己有了100w美金，随着后续股票价格的上涨，这些期权价值达到了500w美金。<br><img src="/2024/06/06/linus/redhat.jpg" alt="redhat"><br>而更疯狂的是VA Linux上市，VA Linux前身是VA research公司，最早的业务是构建和销售装有Linux操作系统的pc，在1998年就占了20%的linux硬件市场。在1999年，VA Linux进行了IPO，上市第一天，价格就从30美金涨到300美金，VA Linux和Redhat一样给了Linus一些股票期权。不过VA linux赶上了互联网泡沫破裂，在01年价格暴跌到7美元，在后续几经辗转，转型更名为Geeknet，并在15年被游戏连锁店GameStop收购。</p>
<p>但是无论如何，Linus都在这两次IPO中获得了巨大的财富，成为财务自由人士。</p>
<h2 id="Linus的人生哲学"><a href="#Linus的人生哲学" class="headerlink" title="Linus的人生哲学"></a>Linus的人生哲学</h2><p>Linus认为驱动人类的是三点动机：生存，人在社会秩序中的位置，以及娱乐。</p>
<p>人类的进化就是从生存到社会行为，从社会行为到娱乐。</p>
<p>在技术的世界里，这种进化模式在重演，现代技术的早期阶段是“技术的生存时代”，技术只是为了生存的更好些，比如更快的织出步，更快的运送商品。</p>
<p>现在的时代是“信息时代”，科技被用于通讯和传播信息，这是社会化的行为，已经超脱出生存范畴。互联网就是典型的代表，有了互联网，通讯技术社会化的阶段就已经到来。</p>
<p>终极目标则是进入娱乐化社会，在娱乐化社会，互联网和无线通讯都是理所当然，那时候思科公司已成往事，世界将有迪斯尼公司说了算。</p>
<p>从这个角度看，生活的最终目的是为了享受乐趣。</p>
<h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>这本传记写于2001年，叙事的部分，就讲到通过Redhat和VA Linux的IPO，Linus获得财务自由为止。在05年，Linus又做了一个改变世界的程序-分布式版本控制系统Git，现在Git已经是世界上最流行的版本控制软件，而这个世界级的软件，Linus只花了10天就完成了第一个版本的开发。</p>
<p>Linus的成神之路，从兴趣开始个人项目，在合适的时间，选择了开源的协作模式，然后通过GPL协议开放，带来了商业的繁荣，最后在开源软件运动的帮助下，最终封神。作为Linux的核心贡献者和项目的领导者，数十年如一日的维护Linux内核，这在很大程度上就是源于他对编程的兴趣，就像黄易说的：唯能极于情,故能极于剑。正因为对编程的热爱，才有了Linus的传奇一生。</p>
<p><strong>本文转载自 <a href="https://zhuanlan.zhihu.com/p/195193559">https://zhuanlan.zhihu.com/p/195193559</a> （有改动）</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习笔记</title>
    <url>/2024/06/06/markdown/</url>
    <content><![CDATA[<h1 id="Markdown学习笔记"><a href="#Markdown学习笔记" class="headerlink" title="Markdown学习笔记"></a>Markdown学习笔记</h1><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>   Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。<br>由于 Markdown 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。</p>
</blockquote>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>可以通过在一行的开头 使用 1-6个# 来创建标题，对应1-6个级别的标题：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 三级标题</span></span><br></pre></td></tr></table></figure>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>段落的写法很简单，直接写文字就行</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个段落</span><br></pre></td></tr></table></figure>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Markdown使用邮件风格的&gt;符号来创建引用块。 例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用</span></span><br></pre></td></tr></table></figure>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><strong>粗体</strong><br>要加粗文本，请在单词或短语的前后各添加两个星号或下划线。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**粗体文字**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__粗体文字__</span></span><br></pre></td></tr></table></figure>
<p><strong>斜体</strong><br>要用斜体显示文本，请在单词或短语前后添加一个星号或下划线。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文字*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_斜体文字_</span></span><br></pre></td></tr></table></figure>
<p><strong>粗斜体</strong></p>
<p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文字*</span>**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__<span class="emphasis">_粗斜体文字_</span>__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">_粗斜体文字_</span>**</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*<span class="strong">__粗斜体文字__</span>*</span></span><br></pre></td></tr></table></figure>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>输入 清单事项1 就会创建一个无序列表， 这里 可以用- 和 +代替;<br>输入 1. 清单事项1 就会创建一个有序列表;<br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符<br>语法如下所示：</p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 红色</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 绿色</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> 蓝色</span><br></pre></td></tr></table></figure>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 红色</span><br><span class="line"><span class="bullet">2.</span> 绿色</span><br><span class="line"><span class="bullet">3.</span> 蓝色</span><br></pre></td></tr></table></figure>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (&#96;) 中</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`print(&quot;hello&quot;)`</span></span><br></pre></td></tr></table></figure>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">---</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">__<span class="emphasis">_</span></span></span><br></pre></td></tr></table></figure>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p>
<p>超链接Markdown语法代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接显示名</span>](<span class="link">超链接地址 &quot;超链接title&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>给链接增加 Title</p>
<p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接显示名</span>](<span class="link">超链接地址 &quot;超链接title&quot;</span>) &quot;超链接titl&quot;</span><br></pre></td></tr></table></figure>
<p>网址和Email地址<br>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;网址或邮箱&gt;</span><br></pre></td></tr></table></figure>
<p>带格式化的链接<br>强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">I love supporting the <span class="strong">**[<span class="string">EFF</span>](<span class="link">https://eff.org</span>)**</span>.</span><br><span class="line">This is the <span class="emphasis">*[<span class="string">Markdown Guide</span>](<span class="link">https://www.markdownguide.org</span>)*</span>.</span><br><span class="line">See the section on [<span class="string">`code`</span>](<span class="link">#code</span>).</span><br></pre></td></tr></table></figure>
<p>引用类型链接<br>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">链接的第一部分格式</span><br><span class="line">引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</span><br><span class="line">尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</span><br><span class="line">链接的第二部分格式</span><br><span class="line">引用类型链接的第二部分使用以下属性设置格式：</span><br><span class="line">放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。</span><br><span class="line">链接的URL，可以选择将其括在尖括号中。</span><br><span class="line">链接的可选标题，可以将其括在双引号，单引号或括号中。</span><br></pre></td></tr></table></figure>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。<br>插入图片Markdown语法代码：!</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">图片alt</span>](<span class="link">图片地址 &quot;图片title&quot;</span>)。 </span><br></pre></td></tr></table></figure>
<p>链接图片<br>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![图片alt</span>](<span class="link">图片地址 &quot;图片title&quot;</span>)](<span class="link">链接地址</span>)</span><br></pre></td></tr></table></figure>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \</p>
<table>
<thead>
<tr>
<th align="left">Character</th>
<th align="right">Name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="right">backslash</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="right">backtick</td>
</tr>
<tr>
<td align="left">*</td>
<td align="right">asterisk</td>
</tr>
<tr>
<td align="left">_</td>
<td align="right">underscore</td>
</tr>
<tr>
<td align="left">{ }</td>
<td align="right">curly braces</td>
</tr>
<tr>
<td align="left">[ ]</td>
<td align="right">brackets</td>
</tr>
<tr>
<td align="left">( )</td>
<td align="right">parentheses</td>
</tr>
<tr>
<td align="left">#</td>
<td align="right">pound sign</td>
</tr>
<tr>
<td align="left">+</td>
<td align="right">plus sign</td>
</tr>
<tr>
<td align="left">-</td>
<td align="right">minus sign (hyphen)</td>
</tr>
<tr>
<td align="left">.</td>
<td align="right">dot</td>
</tr>
<tr>
<td align="left">!</td>
<td align="right">exclamation mark</td>
</tr>
</tbody></table>
<h3 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h3><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可</p>
<h2 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列。可以选择在表的任一端添加管道。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Syntax    | Description |</span><br><span class="line">| --------- | ----------- |</span><br><span class="line">| Header    | Title       |</span><br><span class="line">| Paragraph | Text        |</span><br></pre></td></tr></table></figure>
<p><strong>对齐</strong><br>可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Syntax    | Description |   Test Text |</span><br><span class="line">| :-------- | :---------: | ----------: |</span><br><span class="line">| Header    |    Title    | Here&#x27;s this |</span><br><span class="line">| Paragraph |    Text     |    And more |</span><br></pre></td></tr></table></figure>
<p>格式化表格中的文字<br>可以在表格中设置文本格式。例如，可以添加链接，代码（仅反引号（&#96;）中的单词或短语，而不是代码块）和强调。<br>不能添加标题，块引用，列表，水平规则，图像或HTML标签。<br>在表中转义管道字符<br>可以使用表格的HTML字符代码（|）在表中显示竖线（|）字符。</p>
<h3 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h3><p>Markdown基本语法允许通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，将在代码块之前和之后的行上使用三个反引号（&#96;&#96;&#96;）或三个波浪号（~~~）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">        &quot;firstName&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="code">        &quot;lastName&quot;: &quot;Smith&quot;,</span></span><br><span class="line"><span class="code">        &quot;age&quot;: 25</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<p><strong>语法高亮</strong><br>许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```json</span></span><br><span class="line"><span class="code">&#123;</span></span><br><span class="line"><span class="code">&quot;firstName&quot;: &quot;John&quot;,</span></span><br><span class="line"><span class="code">&quot;lastName&quot;: &quot;Smith&quot;,</span></span><br><span class="line"><span class="code">&quot;age&quot;: 25</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
<h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注使可以添加注释和参考，而不会使文档正文混乱。当创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳至页面底部的脚注内容。</p>
<p>要创建脚注参考，请在方括号（[^1]）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。</p>
<p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（[^1]: My footnote.）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">This is the first footnote.</span></span><br><span class="line"></span><br><span class="line">[<span class="symbol">^bignote</span>]: <span class="link">Here&#x27;s one with multiple paragraphs and code.</span></span><br><span class="line"></span><br><span class="line"><span class="code">    Indent paragraphs to include them in the footnote.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    `&#123; my code &#125;`</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    Add as many paragraphs as you like.</span></span><br></pre></td></tr></table></figure>
<h3 id="标题编号"><a href="#标题编号" class="headerlink" title="标题编号"></a>标题编号</h3><p>许多Markdown处理器支持标题的自定义ID - 一些Markdown处理器会自动添加它们。添加自定义ID允许您直接链接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">### My Great Heading &#123;#custom-id&#125;</span></span><br></pre></td></tr></table></figure>
<p>链接到标题ID (#headid)</p>
<p>通过创建带有数字符号（#）和自定义标题ID的标准链接，可以链接到文件中具有自定义ID的标题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Heading IDs</span>](<span class="link">#heading-ids</span>)</span><br></pre></td></tr></table></figure>
<p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<a href="https://markdown.com.cn/extended-syntax/heading-ids.html#headid">Heading IDs</a>）来链接到标题。</p>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p>一些Markdown处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] Write the press release</span><br><span class="line"><span class="bullet">-</span> [ ] Update the website</span><br><span class="line"><span class="bullet">-</span> [ ] Contact the media</span><br></pre></td></tr></table></figure>
<h3 id="使用-Emoji-表情"><a href="#使用-Emoji-表情" class="headerlink" title="使用 Emoji 表情"></a>使用 Emoji 表情</h3><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。<br>复制和粘贴表情符号<br>在大多数情况下，您可以简单地从Emojipedia<br>等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。<br>Tip: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。.<br>使用表情符号简码<br>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure>

<h3 id="自动网址链接"><a href="#自动网址链接" class="headerlink" title="自动网址链接"></a>自动网址链接</h3><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果您输入’<a href="http://www.example.com',即使您未使用方括号,您的markdown处理器也会自动将其转换为链接./">http://www.example.com&#39;，即使您未使用方括号，您的Markdown处理器也会自动将其转换为链接。</a></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">http://www.example.com</span><br></pre></td></tr></table></figure>
<p>禁用自动URL链接<br>如果您不希望自动链接URL，则可以通过将URL表示为带反引号的代码来删除该链接。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">`http://www.example.com`</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL入门</title>
    <url>/2024/06/06/stl/</url>
    <content><![CDATA[<h1 id="C-STL入门"><a href="#C-STL入门" class="headerlink" title="C++ STL入门"></a>C++ STL入门</h1><h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><blockquote>
<p>STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”与“算法”的集合，所谓的这些“容器”无非就是已经实现好了数据结构，能够让程序设计者更为方便的进行调用，“算法”则顾名思义就是已预先实现好了的算法集合。</p>
</blockquote>
<pre><code>&gt; STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。STL的版本很多，有很多公司或者工作室自定义STL形成各种各样的自定义标准。
</code></pre>
<h2 id="在C-STL中最基本的15个头文件"><a href="#在C-STL中最基本的15个头文件" class="headerlink" title="在C++ STL中最基本的15个头文件"></a>在C++ STL中最基本的15个头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;algorithm&gt; 	&lt;deque&gt; 	&lt;functional&gt; 	&lt;iterator&gt; 	&lt;vector&gt;</span><br><span class="line">&lt;list&gt; 	&lt;map&gt; 	&lt;memory&gt; 	&lt;numeric&gt; 	&lt;queue&gt;</span><br><span class="line">&lt;set&gt; 	&lt;stack&gt; 	&lt;string&gt; 	&lt;array&gt; 	&lt;utility&gt;</span><br></pre></td></tr></table></figure>
<h2 id="STL中包含的六大内容"><a href="#STL中包含的六大内容" class="headerlink" title="STL中包含的六大内容"></a>STL中包含的六大内容</h2><h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>是一种数据结构，也是本章节提的重点，如list(链表)，vector(向量数组)，stack(栈)，队列(queue) ，以模板类的方法提供，为了访问容器中的数据，可以使用由容器类输出的迭代器。</p>
<h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><p>是一种特殊的指针，它提供了访问容器中对象的方法，在程序设计中，它扮演了容器和算法之间的胶合剂，利用迭代器可以快速而安全的对容器内容进行操作，或是进行算法模板的使用。</p>
<h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><p>（部分书籍称为泛型算法，generic algorithms），是一类常用的算法模板，既可以对容器进行操作，同时其开放性也让算法类本身可以针对数组或者是自定义结构体等结构进行直接的操作。</p>
<h3 id="仿函数（Function-object）（又称为函数对象，function-object）"><a href="#仿函数（Function-object）（又称为函数对象，function-object）" class="headerlink" title="仿函数（Function object）（又称为函数对象，function object）"></a>仿函数（Function object）（又称为函数对象，function object）</h3><p>是一种行为类似函数，这样讲可能有些抽象，我们可以理解为一种高级的，重载了()操作符的结构体与类。</p>
<h3 id="迭代适配器（Iterator-Adaptor）"><a href="#迭代适配器（Iterator-Adaptor）" class="headerlink" title="迭代适配器（Iterator Adaptor）"></a>迭代适配器（Iterator Adaptor）</h3><p>是一种用来修饰容器或者仿函数的接口，它使得得带适配器使算法能够以逆向模式，安插模式进行工作，甚至还可以与流配合，它对容器起到非常大的辅助作用，同时他还将迭代器进行了更高级别的抽象。</p>
<h3 id="空间配制器（allocator）"><a href="#空间配制器（allocator）" class="headerlink" title="空间配制器（allocator）"></a>空间配制器（allocator）</h3><p>是负责空间的配置与管理，重点就是对容器的空间申请和空间释放进行管理，你可以理解为C的malloc和free函数，C++的new和delete关键字。</p>
<p><strong>我们主要研究前三项</strong></p>
<p><strong>容器篇</strong><br><a href="https://josiahbristow.github.io/2024/06/06/vector/">Vector容器</a><br>持续更新中,敬请期待…</p>
<p><strong>算法篇</strong><br>持续更新中,敬请期待…</p>
<p><strong>迭代器篇</strong><br>持续更新中,敬请期待…</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言sqrt()函数实现</title>
    <url>/2024/06/06/sqrt/</url>
    <content><![CDATA[<h1 id="C语言sqrt-函数实现"><a href="#C语言sqrt-函数实现" class="headerlink" title="C语言sqrt()函数实现"></a>C语言sqrt()函数实现</h1><p>计算 $x^{2} &#x3D; n$ 的解，令 $f(x)&#x3D;x^{2}-n$，相当于求解 $f(x)&#x3D;0$ 的解，如下图所示。<br><img src="/2024/06/06/sqrt/image.png" alt="牛顿迭代法"><br><strong>牛顿迭代法</strong><br>首先取 $x_{0}$，如果 $x_{0}$ 不是解，做一个经过 $(x_{0},f(x_{0}))$ 这个点的切线，与x轴的交点为 $x_{1}$。</p>
<p>同样的道理，如果 $x_{1}$ 不是解，做一个经过 $(x_{1},f(x_{1}))$ 这个点的切线，与x轴的交点为 $x_{2}$。</p>
<p>以此类推。</p>
<p>以这样的方式得到的xi会无限趋近于 $f(x)&#x3D;0$ 的解。</p>
<p>判断 $x_{i}$是否是 $f(x)&#x3D;0$ 的解有两种方法：</p>
<p>一是直接计算 $f(x_{i})$ 的值判断是否为 $0$，二是判断前后两个解 $x_{i}$ 和 $x_{i}-1$ 是否无限接近。</p>
<p>经过 $(x_{i}, f(x_{i}))$ 这个点的切线方程为 $f(x)&#x3D;f(x_{i})+f^\prime(x_{i})(x - x_{i})$ ，其中 $f^\prime(x)$ 为 $f(x)$ 的导数，本题中为 $2x$。令切线方程等于 $0$，即可求出 $x_{i}+1&#x3D;x_{i} - \frac{f(x_{i})}{f^\prime(x_{i})}$。</p>
<p>继续化简，<br>$$ x_{i}+1&#x3D;x_{i} - \frac{x_{i}^{2} - n}{2x_{i}} &#x3D; x_{i} - \frac{x_{i}}{2} + \frac{n}{2x_{i}} &#x3D; \frac{x_{i}}{2} + \frac{n}{2x_{i}} &#x3D; \frac{x_{i} + \frac{n}{x_{i}}}{2} $$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> last = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res != last) &#123;</span><br><span class="line">                last = res;</span><br><span class="line">                res = (res + x / res) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于牛顿迭代法，可以参考<a href="https://baike.baidu.com/item/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/10887580">百度百科</a>。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>牛顿法</tag>
      </tags>
  </entry>
  <entry>
    <title>最全|《人月神话》书摘，看这一篇就够了</title>
    <url>/2024/06/06/tmmm/</url>
    <content><![CDATA[<h1 id="最全-《人月神话》书摘，看这一篇就够了"><a href="#最全-《人月神话》书摘，看这一篇就够了" class="headerlink" title="最全|《人月神话》书摘，看这一篇就够了"></a>最全|《人月神话》书摘，看这一篇就够了</h1><p>什么叫“人月神话”？</p>
<p>人是程序员，月是时间，，如果1人干10个月如果等同10人干1个月，那就成神话。</p>
<h1 id="001-焦油坑"><a href="#001-焦油坑" class="headerlink" title="001 焦油坑"></a>001 焦油坑</h1><p>过去几十年的大型系统开发就犹如一个焦油坑，很多大型动物在其中剧烈挣扎，他们中大多数开发出了可运行的系统–不过，其中只有非常少数的项目满足了目标、时间进度和预算的要求。</p>
<p>各种团队，大型的和小型的，庞杂的和精干的，一个接一个淹没在了焦油坑中。表面上看起来好像没有任何一个单独的问题会导致困难，每个都能被解决，但是当它们相互纠缠和累积在一起的时候，团队的行动就会变得越来越慢且很难看清问题的本质。</p>
<h1 id="002-人月神话"><a href="#002-人月神话" class="headerlink" title="002 人月神话"></a>002 人月神话</h1><p>缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来影响还大。</p>
<p>我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。</p>
<p>向软件项目中增派人手从三个方面增加了项目必要的总体工作量：</p>
<pre><code>任务重新分配本身和所造成的工作中断；

培训新人员；

额外的相互沟通。
</code></pre>
<p>关于进度安排，我的经验是为1&#x2F;3计划、1&#x2F;6编码、1&#x2F;4构件测试以及1&#x2F;4系统测试。</p>
<p>Brook法则：向进度落后的项目中增加人手，只会使进度更加落后。</p>
<p>特别需要指出的是，不为系统测试安排足够的时间简直就是一场灾难。</p>
<p>在现实情况中，一旦开发团队观察到进度的偏差，总是倾向于对任务进行削减。当项目延期所导致的后续成本非常高时，这常常是唯一可行的方法。</p>
<h1 id="003-外科手术队伍"><a href="#003-外科手术队伍" class="headerlink" title="003 外科手术队伍"></a>003 外科手术队伍</h1><p>小型、精干队伍是最好的–尽可能的少。</p>
<p>需要协作沟通的人员的数量影响着开发成本，因为成本的主要组成部分是相互的沟通和交流，以及更正沟通不当所引起的不良结果（系统调试）。</p>
<p>Mills建议大型项目的每一个部分由一个团队解决，但是该队伍以类似外科手术的方式组建，而并非一拥而上。</p>
<p>一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法–既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。</p>
<h1 id="004-贵族专制、民主政治和系统设计"><a href="#004-贵族专制、民主政治和系统设计" class="headerlink" title="004 贵族专制、民主政治和系统设计"></a>004 贵族专制、民主政治和系统设计</h1><p>为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统，哪怕它们其实包含着许多很好的设计。</p>
<p>同工作的水平分割相比，垂直划分从根本上大大减少了劳动量，结果是使交流彻底地简化，概念完整性得到大幅提高。</p>
<h1 id="005-画蛇添足"><a href="#005-画蛇添足" class="headerlink" title="005 画蛇添足"></a>005 画蛇添足</h1><p>一种普遍倾向是过分地设计第二个系统，向系统添加很多修饰功能和想法，它们曾在第一个系统中被小心谨慎地推迟了。</p>
<p>实际情况中，尽早交流和持续沟通能使结构师有较好的成本意识，以及使开发人员获得对设计的信心，并且不会混淆各自的责任分工。</p>
<p>面对估算过高的难题，结构师有两个选择：削减设计或者建议成本更低的实现方法–挑战估算的结果</p>
<h1 id="006-贯彻执行"><a href="#006-贯彻执行" class="headerlink" title="006 贯彻执行"></a>006 贯彻执行</h1><p>即使是大型的设计团队，设计结果也必须由一个或两个人来完成，以确保这些决定是一致的。</p>
<p>允许体系结构师对实现人员的询问做出电话应答解释是非常重要的，并且必须进行日志记录和整理发布。</p>
<p>对于存有疑问的实现人员，应鼓励他们打电话询问相应的结构师，而不是一边自行猜测一边工作，这是一项很基本的措施。</p>
<h1 id="007-为什么巴比伦塔会失败？"><a href="#007-为什么巴比伦塔会失败？" class="headerlink" title="007 为什么巴比伦塔会失败？"></a>007 为什么巴比伦塔会失败？</h1><p>巴比伦塔项目的失败是因为缺乏交流，以及交流的结果–组织。</p>
<p>“因为左手不知道右手在做什么，从而进度灾难、功能的不合理和系统缺陷纷纷出现。</p>
<p>随着工作的进行，许多小组慢慢地修改自己程序的功能、规模和速度，他们明确或者隐含地更改了一些有效输入和输出结果用法上的约定，而因此给其他部分引发了BUG。</p>
<p>解决方案：</p>
<p>团队应该以尽可能多的方式进行相互之间的交流：非正式、常规项目会议，会上进行简要的技术陈述、共享的正式项目工作手册。举行常规项目会议，会议中，团队一个接一个地进行简要的技术陈述。这种方式非常有用，能澄清成百上千的细小误解。</p>
<p>制定项目工作手册，并实时记录变更：首先，必须在页面上标记发生改变的文本，例如，使用页边上的竖线标记每行变化的文字。第二，分发的变更页附带独立的总结性文字，对变更的重要性以及批注进行记录。</p>
<h1 id="008-胸有成竹"><a href="#008-胸有成竹" class="headerlink" title="008 胸有成竹"></a>008 胸有成竹</h1><p>编码大约只占了问题的六分之一左右，编码估计或者比率的错误可能会导致不合理的荒谬结果。</p>
<p>对常用编程语句而言。生产率似乎是固定的。这个固定的生产率包括了编程中需要注释，并可能存在错误的情况.</p>
<p>使用适当的高级语言，编程的生产率可以提高5倍。</p>
<h1 id="009-削足适履"><a href="#009-削足适履" class="headerlink" title="009 削足适履"></a>009 削足适履</h1><p>在大型的团队中，各个小组倾向于不断地局部优化，以满足自己的目标，而较少考虑队用户的整体影响。这种方向性的问题是大型项目的主要危险。</p>
<p>为了满足目标，每个人都在局部优化自己的程序，很少会有人停下来，考虑一下对客户的整体影响。</p>
<p>培养开发人员从系统整体出发、面向用户的态度是软件编程管理人员最重要的职能。</p>
<h1 id="010-提纲挈领"><a href="#010-提纲挈领" class="headerlink" title="010 提纲挈领"></a>010 提纲挈领</h1><p>如果要制造一台机器，哪些是关键的文档呢？</p>
<p>目标：定义待满足的目标和需要，定义迫切需要的资源、约束和优先级。</p>
<p>首先，书面记录决策是必要的。只有记录下来，分歧才会明朗，矛盾才会突出。项目经理常常会不断发现，许多理应被普遍认同的策略，完全不为团队的一些成员所知。每个文档本身就可以作为检查列表或者数据库。</p>
<p>项目经理的基本职责是使每个人都向着相同的方向前进。项目经理的主要日常工作是沟通，而不是做出决定；文档使各项计划和决策在整个团队范围内得到交流。</p>
<p>通过周期性的回顾，他能清楚项目所处的状态，以及哪些需要重点进行更改和调整。</p>
<h1 id="011-未雨绸缪"><a href="#011-未雨绸缪" class="headerlink" title="011 未雨绸缪"></a>011 未雨绸缪</h1><p>变更的客观需要</p>
<p>对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。</p>
<p>用户的实际需要和用户感觉会随着程序的构建、测试和使用而变化。</p>
<p>软件产品易于掌握的特性和不可见性，导致了它的构建人员（特别容易）面临着永恒的需求变更。</p>
<p>目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。</p>
<p>为变更计划组织结构</p>
<p>当系统发生变化时，管理结构也需要进行调整。只要管理人员和技术人才的天赋允许，老板必须对他们的能力培养给予极大的关注，使管理人员和技术人才具有互换性。</p>
<p>为什么缺陷不能更彻底地被修复？</p>
<p>首先，看上去很轻微的错误，似乎仅仅是局部操作上的失败，实际上却是系统级别的问题，通常这不是很明显。</p>
<p>设计实现的人员越少、接口越少，产生的错误也就越少。</p>
<p>所有修改都倾向于破坏系统的架构，增加了系统的混乱程度。用在修复原有设计上瑕疵的工作量越来越少，而早期维护活动本身的漏洞所引起修复工作越来越多。</p>
<p>随着时间的推移，系统变得越来越无序，修复工作迟早会失去根基 ，尽管理论上系统一直可用，但实际上，整个系统已经面目全非，无法再成为下一步进展的基础。</p>
<p>机器在变化，配置在变化，用户的需求在变化，所以现实系统不可能永远可用。崭新的、对于原有系统的重新设计是完全必要的。</p>
<h1 id="012-干将莫邪"><a href="#012-干将莫邪" class="headerlink" title="012 干将莫邪"></a>012 干将莫邪</h1><p>每个编程人员也保留着编辑器、排序、内存信息转储、磁盘实用程序等工具。 这种方法对软件项目来说是愚蠢的。首先，项目的关键问题是沟通，个性化的工具妨碍–而不是促进沟通。</p>
<p>交互式编程</p>
<p>MIT的Multics项目的成果之一，是它对软件编程系统开发的贡献。在那些系统编程所关注的方面，Multics（以及后续系统，IBM的TSS）和其他交互式计算机系统在概念上有很大的不同：多个级别上数据和程序的共享和保护，可延伸的库管理，以及协助终端用户共同开发的设施。我确信在某些应用上，批处理系统决不会被交互式系统所取代。</p>
<h1 id="013-整体部分"><a href="#013-整体部分" class="headerlink" title="013 整体部分"></a>013 整体部分</h1><p>许许多多的失败完全源于那些产品未精确定义的地方。</p>
<p>“细致的功能定义、详细的规格说明、规范化的功能描述说明以及这些方法的实施，大大减少了系统中必须查找的bug数量。 注: 需求文档越详细，bug越少</p>
<p>在编写任何代码之前，规格说明必须提交给测试小组，以详细地检查说明的完整性和明确性 注: 需求文档给测试过一遍</p>
<p>他将程序开发划分成体系结构设计、设计实现和物理编码实现，每个步骤可以使用自顶向下的方法很好地实现。</p>
<p>好的自顶向下设计从几个方面避免了bug。</p>
<p>首先，清晰的结构和表达方式更容易对需求和模块功能进行精确的描述。</p>
<p>其次，模块分割和模块独立性避免了系统级的bug。</p>
<p>另外，细节的隐藏使结构上的缺陷更加容易识别。</p>
<p>最后，设计在每个精化步骤的层次上是可以测试的，所以测试可以尽早开始，并且每个步骤的重点可以放在合适的级别上。</p>
<p>一些糟糕的系统往往就是试图挽救一个基础很差的设计，而对它添加了很多表面装饰般的补丁。自顶向下的方法减少了这样的企图。</p>
<h1 id="014-祸起萧墙"><a href="#014-祸起萧墙" class="headerlink" title="014 祸起萧墙"></a>014 祸起萧墙</h1><p>当人们听到某个项目的进度发生了灾难性偏离时，可能会认为项目一定是遭受了一系列重大灾难。然而，通常灾祸来自白蚁的肆虐，而不是龙卷风的侵袭。</p>
<h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><p>里程碑的选择只有一个原则，那就是，里程碑必须是具体的、特定的、可度量的事件，能够进行清晰定义。</p>
<p>例如：”结构师和实现人员签字认可的规格说明”，”100%源代码编制完成，纸带打孔完成并输入到磁盘库”，”测试通过了所有的测试用例”。</p>
<p>如果里程碑很模糊，老板就常常会得到一份与实际情况不符的报告。</p>
<p>慢性进度偏离是士气杀手。[Microsoft的Jim McCarthy说：”如果你错过了一个最终期限（deadline），确保制订下一条deadline</p>
<p>如果在某项活动开始之前就着手估计，并且每两周进行一次仔细的修订，根据实际情况动态调整时间。当里程碑没有正确反映损失的时间，并对人们形成误导，以致事态无法挽回的时候，它会彻底碾碎小组的士气。</p>
<h3 id="保持进度透明可见"><a href="#保持进度透明可见" class="headerlink" title="保持进度透明可见"></a>保持进度透明可见</h3><p>一线经理的利益和老板的利益是内在冲突的。一线经理担心如果汇报了问题，老板会采取行动,这些行动会取代经理的作用，降低自己的威信，搞乱了其他计划。所以，只要项目经理认为自己可以独立解决问题，他就不会告诉老板。</p>
<p>有两种掀开毯子把污垢展现在老板面前的方法，它们必须都被采用。</p>
<ol>
<li><p>一种是减少角色冲突和鼓励状态共享<br>  减少角色的冲突。老板必须规范自己，不对项目经理可以解决的问题做出反应。当项目经理了解到老板收到项目报告之后不会惊慌，或者不会越俎代庖时，他就逐渐会提交真实的评估结果。</p>
</li>
<li><p>另一种是猛地拉开地毯<br>猛地拉开地毯。不论协作与否，拥有能了解状态真相的评审机制是必要的。PERT图以及频繁的里程碑是这种评审的基础。大型项目中，可能需要每周对某些部分进行评审，大约一个月左右进行整体评审。</p>
</li>
<li><p>没有银弹软件工程中的根本和次要问题<br>没有任何技术或管理上的进展，能够独立地许诺十年内使生产率、可靠性或简洁性获得数量级上的进步。因为软件有无法规避的特性：复杂度、一致性、可变性、不可见性。</p>
</li>
</ol>
<h3 id="产品复杂度："><a href="#产品复杂度：" class="headerlink" title="产品复杂度："></a>产品复杂度：</h3><p>由于复杂度，团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；</p>
<p>由于复杂度，列举和理解所有可能的状态十分困难，影响了产品的可靠性；</p>
<p>由于函数的复杂度，函数调用变得困难，导致程序难以使用；</p>
<p>由于结构性复杂度，程序难以在不产生副作用的情况下用新函数扩充；由于结构性复杂度，造成很多安全机制状态上的不可见性。</p>
<p>复杂度不仅仅导致技术上的困难，还引发了很多管理上的问题。它使全面理解问题变得困难，从而妨碍了概念上的完整性；它使所有离散出口难以寻找和控制；它引起了大量学习和理解上的负担，使开发慢慢演变成了一场灾难。</p>
<h3 id="软件可变性："><a href="#软件可变性：" class="headerlink" title="软件可变性："></a>软件可变性：</h3><p>软件实体经常会遭受到持续的变更压力</p>
<p>现实工作中，经常发生两种情况。</p>
<p>当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。</p>
<p>其次，软件一定是在某种计算机硬件平台上开发，成功软件的生命期通常比当初的计算机硬件平台要长。即使不是更换计算机，则有可能是换新型号的磁盘、显示器或者打印机。软件必须与各种新生事物保持一致。</p>
<h3 id="软件不可见性："><a href="#软件不可见性：" class="headerlink" title="软件不可见性："></a>软件不可见性：</h3><p>软件是不可见的和无法可视化的。 其中的秘密就是逐步发育成长，而不是一次性搭建。</p>
<p>软件开发是一件棘手的事情，并不会有魔术般的解决方案，现在是从业者研究和分析革命性进展的时刻，而不是等待或希望它的出现。</p>
<p>现在有可能可以在软件生产率上取得逐步的进展，而不是等待不可能到来的大突破。</p>
<p><strong>转载至<a href="https://zhuanlan.zhihu.com/p/27521161">https://zhuanlan.zhihu.com/p/27521161</a> ，有改动</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>人月神话</tag>
      </tags>
  </entry>
  <entry>
    <title>读懂C/C++类型声明的黄金法则</title>
    <url>/2024/06/06/type/</url>
    <content><![CDATA[<h1 id="读懂C-C-类型声明的黄金法则"><a href="#读懂C-C-类型声明的黄金法则" class="headerlink" title="读懂C&#x2F;C++类型声明的黄金法则"></a>读懂C&#x2F;C++类型声明的黄金法则</h1><ol>
<li>找到变量名，如果没有变量名，找到最里面的结构</li>
<li>向右看，读出你看到的东西，但不要跳过括号</li>
<li>再向左看，读出你看到的东西，但不要也跳过括号</li>
<li>如果有括号，跳出一层括号</li>
<li>重复上述步骤，直到你读出最终类型</li>
</ol>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=602127548&bvid=BV1mB4y1L7HB&cid=807847346&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++类型声明</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector容器</title>
    <url>/2024/06/06/vector/</url>
    <content><![CDATA[<h1 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Vector可以翻译为向量，或向量数组，至于为什么以向量命名，可以理解为一维空间也是存在向量的。<br>Vector是最简单的序列是容器，就像数组一样，向量使用连续的存储位置作为元素，这意味着它们的元素也可以使用常量指向其元素的偏移来访问，与数组一样有效。但与数组不同，它们的大小可以动态变化，其存储由容器自动处理。<br>总结一下Vector就是一个动态创建空间，且预先加载了常用的数组操作的数组</p>
</blockquote>
<h2 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vector<T> v1;</td>
<td align="right">v1 是一个元素类型为 T 的空 vector</td>
</tr>
<tr>
<td align="left">vector<T> v2(v1);</td>
<td align="right">使用 v2 中所有元素初始化 v1</td>
</tr>
<tr>
<td align="left">vector<T> v2 &#x3D; v1;</td>
<td align="right">同上</td>
</tr>
<tr>
<td align="left">vector<T> v3(n, val);</td>
<td align="right">v3 中包含了 n 个值为 val 的元素</td>
</tr>
<tr>
<td align="left">vector<T> v4(n);</td>
<td align="right">v3 中包含了 n 个默认值初始化的元素</td>
</tr>
<tr>
<td align="left">vector<T> v5{a, b, c…};</td>
<td align="right">使用 a, b, c… 初始化 v5</td>
</tr>
<tr>
<td align="left">vector<T> v1;</td>
<td align="right">同上</td>
</tr>
<tr>
<td align="left">vector&lt;vector<int>&gt; matrix(M,vector<int>(N));</td>
<td align="right">二维数组初始化</td>
</tr>
</tbody></table>
<h2 id="vector-常用基础操作"><a href="#vector-常用基础操作" class="headerlink" title="vector 常用基础操作"></a>vector 常用基础操作</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v.empty();</td>
<td align="right">如果 v 为空则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="left">v.size();</td>
<td align="right">返回 v 中元素的个数</td>
</tr>
<tr>
<td align="left">v.push_back(val);</td>
<td align="right">向 vector 的尾端添加值为 val 的元素。</td>
</tr>
<tr>
<td align="left">v.pop_back(val);</td>
<td align="right">删除尾元素，返回void。vector同样 不支持 pop_front 操作。</td>
</tr>
<tr>
<td align="left">v[n];</td>
<td align="right">返回 v 中第 n 个位置上元素的引用，不能用下标操作添加元素</td>
</tr>
<tr>
<td align="left">v.back();</td>
<td align="right">返回 v 中最后一个元素的引用</td>
</tr>
<tr>
<td align="left">v.front();</td>
<td align="right">返回 v 中第一个元素的引用</td>
</tr>
<tr>
<td align="left">v1 &#x3D; v2;</td>
<td align="right">用 v2 中的元素替换 v1 中的元素</td>
</tr>
<tr>
<td align="left">v1 &#x3D; {a, b, c…};</td>
<td align="right">用元素 {a, b, c…} 替换 v1 中的元素</td>
</tr>
<tr>
<td align="left">v1 &#x3D;&#x3D; v2;</td>
<td align="right">当且仅当拥有相同数量且相同位置上值相同的元素时，v1 与 v2 相等</td>
</tr>
<tr>
<td align="left">v1 !&#x3D; v2;</td>
<td align="right">自行体会</td>
</tr>
<tr>
<td align="left">&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;</td>
<td align="right">以字典序进行比较</td>
</tr>
</tbody></table>
<h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><p><strong>插入</strong></p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void push_back(const T&amp; x);</td>
<td align="right">向量尾部增加一个元素X</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,const T&amp; x);</td>
<td align="right">向量中迭代器指向元素前增加一个元素x</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,int n,const T&amp; x);</td>
<td align="right">向量中迭代器指向元素前增加n个相同的元素x</td>
</tr>
<tr>
<td align="left">iterator insert(iterator it,const_iterator first,const_iterator last);</td>
<td align="right">向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</td>
</tr>
</tbody></table>
<p><strong>删除</strong></p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iterator erase(iterator it);</td>
<td align="right">删除向量中迭代器指向元素</td>
</tr>
<tr>
<td align="left">iterator erase(iterator first,iterator last);</td>
<td align="right">删除向量中[first,last)中元素</td>
</tr>
<tr>
<td align="left">void pop_back();</td>
<td align="right">删除向量中最后一个元素</td>
</tr>
<tr>
<td align="left">void clear();</td>
<td align="right">清空向量中所有元素</td>
</tr>
</tbody></table>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reference at(int pos);</td>
<td align="right">返回pos位置元素的引用</td>
</tr>
<tr>
<td align="left">reference front();</td>
<td align="right">返回首元素的引用</td>
</tr>
<tr>
<td align="left">reference back();</td>
<td align="right">返回尾元素的引用</td>
</tr>
<tr>
<td align="left">iterator begin();</td>
<td align="right">返回向量头指针，指向第一个元素</td>
</tr>
<tr>
<td align="left">iterator end();</td>
<td align="right">返回向量尾指针，指向向量最后一个元素的下一个位置</td>
</tr>
<tr>
<td align="left">reverse_iterator rbegin();</td>
<td align="right">反向迭代器，指向最后一个元素</td>
</tr>
<tr>
<td align="left">reverse_iterator rend();</td>
<td align="right">反向迭代器，指向第一个元素之前的位置</td>
</tr>
</tbody></table>
<h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int size() const;</td>
<td align="right">返回向量中元素的个数</td>
</tr>
<tr>
<td align="left">int capacity() const;</td>
<td align="right">返回当前向量所能容纳的最大元素值</td>
</tr>
<tr>
<td align="left">int max_size() const;</td>
<td align="right">返回最大可允许的vector元素数量值</td>
</tr>
</tbody></table>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool empty() const;</td>
<td align="right">判断向量是否为空，若为空，则向量中无元素</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th align="left">代码</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">void swap(vector&amp;);</td>
<td align="right">交换两个同类型向量的数据</td>
</tr>
<tr>
<td align="left">void assign(int n,const T&amp; x);</td>
<td align="right">设置向量中前n个元素的值为x</td>
</tr>
<tr>
<td align="left">void assign(const_iterator first,const_iterator last);</td>
<td align="right">向量中[first,last)中元素设置成当前向量元素</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>STL</category>
        <category>vector</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim配置教学</title>
    <url>/2024/06/08/neovim/</url>
    <content><![CDATA[<h1 id="Neovim配置教学"><a href="#Neovim配置教学" class="headerlink" title="Neovim配置教学"></a>Neovim配置教学</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>也许你使用过 Vi 或者 Vim ，但你要明确的是 Neovim 与这两者并不是同一软件。</strong></p>
<blockquote>
<p>Vim本身是由Bram Moolenaar在90年代初对已经过时的Vi进行改进的克隆。Moolenaar本人忽略了Vim的发展和行动过程。经过几十年的发展，Vim的源代码开始变得陈旧和难以维护。它很臃肿，一些代码没有被优化，而且它目前的功能集也没有很好的老化。<br>但是，Neovim是从头开始重建的。冗余的和几十年前的代码被清除掉了。与此同时，维护者们试图为用户提供和Vim一样的功能。虽然，它确实预先打包了 “可选类固醇”来消费。在文章的其余部分会有更多关于它的内容。</p>
</blockquote>
<p>至于为什我们要使用 Neovim 可以参考这篇文章 <a href="https://juejin.cn/post/7090094882588459045">Vim还是Neovim？为什么你应该使用后者？</a></p>
<p><strong>另外我们将使用 Lua 语言来配置 Neovim</strong></p>
<p>是如果你还不会使用 Lua 最好先去学习一下<br>可以搜索一下 <a href="https://learnxinyminutes.com/docs/lua/s">Learn Lua in Y minutes</a> ,学习一下 Lua</p>
<h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="来看一下我的的目录结构⬇️"><a href="#来看一下我的的目录结构⬇️" class="headerlink" title="来看一下我的的目录结构⬇️"></a>来看一下我的的目录结构⬇️</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvim</span><br><span class="line">├── ftplugin</span><br><span class="line">│   ├── cpp.vim</span><br><span class="line">│   ├── c.vim</span><br><span class="line">│   └── python.vim</span><br><span class="line">├── init.lua</span><br><span class="line">├── lazy-lock.json</span><br><span class="line">└── lua</span><br><span class="line">    ├── config</span><br><span class="line">    │   ├── vim-autocmds.lua</span><br><span class="line">    │   ├── vim-keymaps.lua</span><br><span class="line">    │   └── vim-options.lua</span><br><span class="line">    └── plugins</span><br><span class="line">        ├── alpha.lua</span><br><span class="line">        ├── autopairs.lua</span><br><span class="line">        ├── bufferline.lua</span><br><span class="line">        ├── catppuccin.lua</span><br><span class="line">        ├── comment.lua</span><br><span class="line">        ├── competitive.lua</span><br><span class="line">        ├── completions.lua</span><br><span class="line">        ├── dap.lua</span><br><span class="line">        ├── dressing.lua</span><br><span class="line">        ├── flash.lua</span><br><span class="line">        ├── floaterm.lua</span><br><span class="line">        ├── increname.lua</span><br><span class="line">        ├── lsp-config.lua</span><br><span class="line">        ├── lualine.lua</span><br><span class="line">        ├── mini.lua</span><br><span class="line">        ├── multicursors.lua</span><br><span class="line">        ├── neotree.lua</span><br><span class="line">        ├── noice.lua</span><br><span class="line">        ├── telescope.lua</span><br><span class="line">        ├── toggleterm.lua</span><br><span class="line">        ├── treesitter.lua</span><br><span class="line">        ├── trouble.lua</span><br><span class="line">        └── which-key.lua</span><br></pre></td></tr></table></figure>
<p>你将会在下面的教学中逐一创建它们。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>。。。<br>。。。</p>
]]></content>
      <categories>
        <category>Tools</category>
        <category>Neovim</category>
      </categories>
  </entry>
  <entry>
    <title>CMake学习笔记</title>
    <url>/2024/06/10/cmake/</url>
    <content><![CDATA[<p><img src="/2024/06/10/cmake/CMake-Logo.svg" alt="CMake-Logo"><br>CMake[<a href="https://cmake.org/]">https://cmake.org/]</a></p>
<h1 id="CMake学习笔记-🎉"><a href="#CMake学习笔记-🎉" class="headerlink" title="CMake学习笔记 🎉"></a>CMake学习笔记 🎉</h1><h2 id="Cmake-简介"><a href="#Cmake-简介" class="headerlink" title="Cmake 简介"></a>Cmake 简介</h2><blockquote>
<p>CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile（通过 make 命令进行项目的构建），大多是IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。<br>而 CMake 恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译<br>流程如下图：<br><img src="/2024/06/10/cmake/image-20230309130644912.png" alt="流程图"></p>
<ul>
<li>蓝色🟦虚线表示使用makefile构建项目的过程</li>
<li>红色🟥实线表示使用cmake构建项目的过程<br>介绍完CMake的作用之后，再来总结一下它的优点：</li>
<li>跨平台</li>
<li>能够管理大型项目</li>
<li>简化编译构建过程和编译过程</li>
<li>可扩展：可以为 Cmake 编写特定功能的模块，扩充 Cmake 功能</li>
</ul>
</blockquote>
<h2 id="CMake基本语法"><a href="#CMake基本语法" class="headerlink" title="CMake基本语法"></a>CMake基本语法</h2><p>CMake支持大写、小写、混合大小写的命令，按自己喜好来就可以。不过为了方便，本文大多数采用小写。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>CMake 使用 # 进行行注释，使用 #[[ ]] 形式进行块注释。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[</span></span><br><span class="line"><span class="comment">	块注释</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>
<h3 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h3><p>以下三个命令是使用CMake构建最简单的一个项目所需要的命令。<br><code>cmake_minimum_required</code>：指定使用的 CMake 的最低版本；<br><code>project</code>：定义工程名称，并可指定工程的版本、工程描述等；<br><code>add_executable</code>：将指定的源码编译生成为一个可执行程序。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>) <span class="comment"># 指定使用的 C++ 标准，</span></span><br><span class="line"><span class="keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)</span><br></pre></td></tr></table></figure>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在 CMake 中，变量的值始终是字符串类型，且区分大小写。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置一个普通变量，&lt;variable&gt; 表示变量名，&lt;value&gt;... 表示一个或多个参数</span></span><br><span class="line"><span class="keyword">set</span>(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE]) </span><br><span class="line"><span class="comment"># 使用 $&#123;&lt;variable&gt;&#125; 的形式取变量的值。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 add.c div.c main.c mult.c sub.c 存储到 SRC 变量中</span></span><br><span class="line"><span class="keyword">set</span>(SRC add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取变量 SRC 的值</span></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC&#125;</span>) </span><br></pre></td></tr></table></figure>
<h3 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h3><p>程序的输出可能是一个可执行文件、可能是制作的共享库，可以通过以下命令设置指定的输出路径。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将输出路径指定为 /xxx/xxx</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH /xxx/xxx)</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">set</span>(RUNTIME_OUTPUT_DIRECTORY /xxx/xxx)</span><br></pre></td></tr></table></figure>
<p><strong>注意⚠️</strong><br><code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>RUNTIME_OUTPUT_DIRECTORY</code> 是预定义的宏，当设置了 <code>RUNTIME_OUTPUT_DIRECTORY</code> 时<code>EXECUTABLE_OUTPUT_PATH</code> 就失效了。</p>
<h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h3><p>在 CMake 中，可以使用 <code>aux_source_directory</code> 命令或者 <code>file</code> 命令 搜索项目中的头文件或源文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 &lt;dir&gt; 目录下的源文件存储到 &lt;variable&gt; 变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>
<p><code>file</code> 命令具有很多功能，这里介绍搜索文件的功能。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB &lt;variable&gt; [LIST_DIRECTORIES <span class="keyword">true</span>|<span class="keyword">false</span>] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expressions&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE &lt;variable&gt; [FOLLOW_SYMLINKS] [LIST_DIRECTORIES <span class="keyword">true</span>|<span class="keyword">false</span>] [RELATIVE &lt;path&gt;] [CONFIGURE_DEPENDS] [&lt;globbing-expressions&gt;...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;globbing-expressions&gt;... 搜索的表达式，可以是指定目录，指定目录下的某种文件，理解为一种正则表达式就好了；GLOB 非递归搜索；GLOB_RECURSE 递归搜索；&lt;variable&gt; 搜索结果保存的变量名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># 非递归搜索 /xxx/xxx 下的 *.cpp 源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC /xxx/xxx/*.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索 /xxx/xxx 下的所有 *.h 头文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE HEADER /xxx/xxx/*.h)</span><br></pre></td></tr></table></figure>
<h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><p>指定源文件对应的头文件，<code>include_directories(/xxx/include)</code> ，源文件对应的头文件指定在 &#x2F;xxx&#x2F;include 目录下。</p>
<h3 id="制作动态库和静态库"><a href="#制作动态库和静态库" class="headerlink" title="制作动态库和静态库"></a>制作动态库和静态库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数作用：生成库。</span></span><br><span class="line"><span class="comment"># 参数lib_name：是要生成的库名称，</span></span><br><span class="line"><span class="comment"># 参数STATIC/SHARED：指定生成静态库或动态库，</span></span><br><span class="line"><span class="comment"># 参数src：指明库的生成所需要的源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(lib_name STATIC/SHARED src) </span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将目标名称 target1 的 prop1 属性设置为 value1；</span></span><br><span class="line"><span class="comment"># 将目标名称 target2 的 prop2 属性设置为 value2.</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure>
<h3 id="链接静态库和动态库"><a href="#链接静态库和动态库" class="headerlink" title="链接静态库和动态库"></a>链接静态库和动态库</h3><pre><code class="cmake"># 函数作用：查找库，并把库的绝对路径和名称存储到第一个参数里
# 参数var：用于存储查找到的库
# 参数lib_name：想要查找的库的名称，默认是查找动态库，想要指定查找动态库或静态库
#       可以加后缀，例如 funcname.so 或 funcname.a 
# 参数lib_path：想要从哪个路径下查找库，可以指定多个路径
find_library(var lib_name lib_path1 lib_path2)

# 指定静态库的路径，&lt;lib path&gt; 表示静态库的路径
link_directories(&lt;lib path&gt;)

# 链接静态库的命令，&lt;static lib&gt; 表示静态库的名称，可以是全名 libxxx.a，或掐头去尾 xxx
link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])
</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
</search>
